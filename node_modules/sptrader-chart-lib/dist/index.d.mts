import React, { Component, ReactNode, ErrorInfo, RefObject } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { ISeriesPrimitive, SeriesAttachedParameter, ISeriesPrimitivePaneView, SeriesPrimitivePaneViewZOrder, DeepPartial, ChartOptions, CandlestickSeriesOptions, IChartApi, ISeriesApi, CandlestickData } from 'lightweight-charts';
export { BusinessDay, CandlestickData, CandlestickSeriesOptions, ChartOptions, CrosshairMode, CrosshairOptions, DeepPartial, GridOptions, IChartApi, ISeriesApi, LayoutOptions, LineStyle, MouseEventParams, PriceScaleMode, PriceScaleOptions, SeriesMarker, SeriesType, Time, TimeScaleOptions, UTCTimestamp, WatermarkOptions, createChart, isBusinessDay, isUTCTimestamp } from 'lightweight-charts';
import * as zustand from 'zustand';

/**
 * MARKET DATA CHART
 * Generic chart component for all market data (forex, bitcoin, crypto, etc.)
 * Based on the proven Bitcoin pattern with cascade aggregates
 *
 * Features:
 * - Fractal zoom with automatic timeframe switching
 * - Real-time data updates
 * - Works with any asset using the cascade pattern
 */

interface MarketDataChartProps {
    symbol?: string;
    timeframe?: string;
    onTimeframeChange?: (timeframe: string) => void;
    isFullscreen?: boolean;
    onToggleFullscreen?: () => void;
    enableTimeframeAutoSwitch?: boolean;
    /** Preload adjacent timeframes in background for faster switching */
    preloadAdjacentTimeframes?: boolean;
}
declare const MarketDataChart: React.FC<MarketDataChartProps>;

interface ReconnectionConfig {
    maxRetries?: number;
    initialDelay?: number;
    maxDelay?: number;
    backoffMultiplier?: number;
    onStatusChange?: (status: ConnectionStatus) => void;
    onError?: (error: Error, retryCount: number) => void;
    onConnected?: () => void;
    onDisconnected?: (reason?: string) => void;
    onMaxRetriesReached?: () => void;
}
type ConnectionStatus = 'connected' | 'connecting' | 'disconnected' | 'error' | 'reconnecting';
declare class ReconnectionManager {
    private config;
    private retryCount;
    private retryTimer?;
    private currentDelay;
    private isDestroyed;
    private connectFn;
    private currentStatus;
    constructor(connectFunction: () => Promise<void>, config?: ReconnectionConfig);
    private setStatus;
    connect(): Promise<void>;
    private handleConnectionSuccess;
    private handleConnectionError;
    private handleMaxRetriesReached;
    private scheduleRetry;
    disconnect(reason?: string): void;
    private clearRetryTimer;
    resetRetryCount(): void;
    getStatus(): ConnectionStatus;
    getRetryCount(): number;
    getNextRetryDelay(): number;
    destroy(): void;
}
declare class WebSocketReconnectionManager extends ReconnectionManager {
    private ws?;
    private url;
    private protocols?;
    private heartbeatInterval?;
    private heartbeatTimeout?;
    private lastPingTime?;
    private pingInterval;
    private pongTimeout;
    constructor(url: string, protocols?: string | string[], config?: ReconnectionConfig & {
        enableHeartbeat?: boolean;
        pingInterval?: number;
        pongTimeout?: number;
        onMessage?: (event: MessageEvent) => void;
    });
    private createWebSocket;
    private startHeartbeat;
    private stopHeartbeat;
    private sendPing;
    private handlePong;
    send(data: string | ArrayBuffer | Blob): void;
    close(code?: number, reason?: string): void;
    getWebSocket(): WebSocket | undefined;
}

interface StreamStatusProps {
    status: ConnectionStatus;
    symbol?: string;
    message?: string;
    onRetry?: () => void;
    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    compact?: boolean;
}
declare const StreamStatus: React.FC<StreamStatusProps>;
declare const MinimalStreamStatus: React.FC<Pick<StreamStatusProps, 'status'>>;

interface Props {
    children: ReactNode;
    fallback?: (error: Error, errorInfo: ErrorInfo, retry: () => void) => ReactNode;
    onError?: (error: Error, errorInfo: ErrorInfo) => void;
    resetKeys?: Array<string | number>;
    resetOnPropsChange?: boolean;
}
interface State {
    hasError: boolean;
    error: Error | null;
    errorInfo: ErrorInfo | null;
}
declare class ErrorBoundary extends Component<Props, State> {
    constructor(props: Props);
    static getDerivedStateFromError(error: Error): State;
    componentDidCatch(error: Error, errorInfo: ErrorInfo): void;
    componentDidUpdate(prevProps: Props): void;
    resetErrorBoundary: () => void;
    render(): string | number | boolean | Iterable<React.ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;
}
declare const ChartErrorBoundary: React.FC<{
    children: ReactNode;
    onError?: (error: Error) => void;
}>;

interface LoadingStateProps {
    message?: string;
    subMessage?: string;
    showSpinner?: boolean;
    height?: string | number;
    overlay?: boolean;
}
declare const LoadingState: React.FC<LoadingStateProps>;
declare const ChartLoadingState: React.FC<{
    symbol?: string;
    timeframe?: string;
}>;
declare const ChartSkeleton: React.FC<{
    height?: string | number;
}>;
declare const InlineLoader: React.FC<{
    text?: string;
}>;

interface EmptyStateProps {
    title?: string;
    message?: string;
    icon?: React.ReactNode;
    action?: {
        label: string;
        onClick: () => void;
    };
    height?: string | number;
}
declare const EmptyState: React.FC<EmptyStateProps>;
declare const ChartEmptyState: React.FC<{
    symbol?: string;
    onSelectSymbol?: () => void;
}>;
declare const NoDataInRangeState: React.FC<{
    timeframe: string;
    onChangeTimeframe?: () => void;
}>;

interface CountdownTimerOptions {
    timeframe: string;
    position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    offset?: {
        x: number;
        y: number;
    };
    onNewCandleBoundary?: (time: number) => void;
}
declare class CountdownTimerPaneView implements ISeriesPrimitivePaneView {
    private _primitive;
    constructor(primitive: CountdownTimerPrimitive);
    zOrder(): SeriesPrimitivePaneViewZOrder;
    renderer(): {
        draw: (target: any) => void;
    };
}
declare class CountdownTimerPrimitive implements ISeriesPrimitive<any> {
    private _paneViews;
    private _timeframe;
    private _position;
    private _offset;
    private _onNewCandleBoundary?;
    private _countdown;
    private _color;
    private _intervalId;
    private _requestUpdate;
    private _hasTriggered;
    constructor(options: CountdownTimerOptions);
    updateTimeframe(timeframe: string): void;
    attached(param: SeriesAttachedParameter<any>): void;
    detached(): void;
    paneViews(): CountdownTimerPaneView[];
    updateAllViews(): void;
    private _startCountdown;
    private _stopCountdown;
    private _calculateSecondsToNextCandle;
    private _formatCountdown;
    private _getCountdownColor;
    private _updateCountdown;
    getData(): {
        countdown: string;
        color: string;
        position: "top-left" | "top-right" | "bottom-left" | "bottom-right";
        offset: {
            x: number;
            y: number;
        };
    };
}

interface WatermarkOptions {
    timeframe: string;
    opacity?: number;
    fontSize?: number;
}
declare class WatermarkPaneView implements ISeriesPrimitivePaneView {
    private _primitive;
    constructor(primitive: TimeframeWatermarkPrimitive);
    zOrder(): SeriesPrimitivePaneViewZOrder;
    renderer(): {
        draw: (target: any) => void;
    };
}
declare class TimeframeWatermarkPrimitive implements ISeriesPrimitive<any> {
    private _paneViews;
    private _timeframe;
    private _opacity;
    private _fontSize;
    private _requestUpdate;
    constructor(options: WatermarkOptions);
    updateTimeframe(timeframe: string): void;
    attached(param: SeriesAttachedParameter<any>): void;
    detached(): void;
    paneViews(): WatermarkPaneView[];
    updateAllViews(): void;
    getData(): {
        timeframe: string;
        opacity: number;
        fontSize: number;
    };
}

interface ChartTheme {
    backgroundColor: string;
    textColor: string;
    gridColor: string;
    borderColor: string;
    upColor: string;
    downColor: string;
    wickUpColor: string;
    wickDownColor: string;
}
declare const darkTheme: ChartTheme;
declare const defaultChartOptions: (theme: ChartTheme) => DeepPartial<ChartOptions>;
declare const defaultSeriesOptions: (theme: ChartTheme) => DeepPartial<CandlestickSeriesOptions>;
interface UseChartSetupOptions {
    theme?: ChartTheme;
    chartOptions?: DeepPartial<ChartOptions>;
    seriesOptions?: DeepPartial<CandlestickSeriesOptions>;
}
interface UseChartSetupReturn {
    chart: IChartApi | null;
    series: ISeriesApi<'Candlestick'> | null;
    isReady: boolean;
}
/**
 * Hook to setup and manage a TradingView Lightweight Chart
 *
 * @param containerRef - Reference to the container element
 * @param options - Optional theme and configuration options
 * @returns Chart and series references
 */
declare function useChartSetup(containerRef: RefObject<HTMLDivElement>, options?: UseChartSetupOptions): UseChartSetupReturn;

interface VisibleRange {
    from: number;
    to: number;
}
interface UseChartZoomOptions {
    onBarSpacingChange?: (barSpacing: number) => void;
    onVisibleRangeChange?: (range: VisibleRange | null) => void;
    barSpacingCheckInterval?: number;
}
interface UseChartZoomReturn {
    isShiftPressed: boolean;
    lockedLeftEdge: number | null;
    visibleRange: VisibleRange | null;
    barSpacing: number;
    zoomIn: (factor?: number) => void;
    zoomOut: (factor?: number) => void;
    resetZoom: () => void;
    scrollToTime: (time: number, animate?: boolean) => void;
    setVisibleRange: (range: VisibleRange) => void;
    maintainLeftEdgeLock: () => void;
}
/**
 * Hook to manage chart zoom functionality including:
 * - Shift key handling for left edge locking
 * - Visible range tracking
 * - Bar spacing monitoring
 * - Zoom utilities
 */
declare function useChartZoom(chart: IChartApi | null, options?: UseChartZoomOptions): UseChartZoomReturn;

interface ChartData$2 {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}
interface UseChartDataOptions {
    autoLoad?: boolean;
    range?: {
        from: number;
        to: number;
    };
}
interface UseChartDataReturn {
    data: ChartData$2[];
    isLoading: boolean;
    error: string | null;
    fetchData: (options?: {
        forceRefresh?: boolean;
        range?: {
            from: number;
            to: number;
        };
    }) => Promise<void>;
    invalidateCache: (pattern?: string) => void;
    setDefaultRange: (from: number, to: number) => void;
}
declare function useChartData(symbol: string, timeframe: string, options?: UseChartDataOptions): UseChartDataReturn;

interface UseCountdownTimerOptions {
    onNewCandleBoundary?: (time: number) => void;
    updateInterval?: number;
    warningThreshold?: number;
    criticalThreshold?: number;
}
interface UseCountdownTimerReturn {
    countdown: string;
    countdownColor: string;
    secondsRemaining: number;
    isNearBoundary: boolean;
    isPastBoundary: boolean;
}
/**
 * Hook to manage countdown timer to next candle boundary
 *
 * @param timeframe - Current chart timeframe
 * @param options - Configuration options
 * @returns Countdown state and utilities
 */
declare function useCountdownTimer(timeframe: string, options?: UseCountdownTimerOptions): UseCountdownTimerReturn;
/**
 * Calculate the time of the next candle boundary
 */
declare function getNextCandleTime(timeframe: string): number;
/**
 * Calculate the current candle's start time
 */
declare function getCurrentCandleTime(timeframe: string): number;

interface UsePlaceholderCandleOptions {
    onPlaceholderCreated?: (time: number) => void;
    resetDelay?: number;
}
interface UsePlaceholderCandleReturn {
    createPlaceholder: (candleTime: number) => void;
    updateWithRealData: (data: CandlestickData[]) => void;
    hasPlaceholder: () => boolean;
    getPlaceholderTime: () => number | null;
    resetTrigger: () => void;
}
/**
 * Hook to manage placeholder candles on the chart
 *
 * Placeholders are temporary candles created at timeframe boundaries
 * before real data arrives, using the previous candle's close price
 *
 * @param series - The chart series to add placeholders to
 * @param options - Configuration options
 */
declare function usePlaceholderCandle(series: ISeriesApi<'Candlestick'> | null, options?: UsePlaceholderCandleOptions): UsePlaceholderCandleReturn;
/**
 * Helper function to calculate candle time for a given timeframe
 */
declare function calculateCandleTime(timestamp: number, timeframe: string): number;

interface ChartData$1 {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}
interface Tick {
    time: number;
    price: number;
    volume: number;
}
interface Candle {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number;
}
interface DataRequest {
    symbol: string;
    timeframe: string;
    from: number;
    to: number;
}
interface FetchCandlesArgs {
    request: DataRequest;
}
interface StreamStatusData {
    connected: boolean;
    message: string;
}
interface ViewState {
    timeframe: string;
    visibleFrom: number;
    visibleTo: number;
    barSpacing: number;
}
interface ChartConfig {
    theme?: 'light' | 'dark';
    timeframes?: string[];
    defaultTimeframe?: string;
    cacheTTL?: number;
    autoTimeframeSwitch?: boolean;
    barSpacingThresholds?: Record<string, number>;
}
interface DataProvider {
    fetchCandles: (symbol: string, timeframe: string, from: number, to: number) => Promise<{
        data: ChartData$1[];
        metadata?: {
            data_from: number;
            data_to: number;
            total_ticks?: number;
        };
    }>;
    subscribeToUpdates?: (symbol: string, callback: (data: ChartData$1) => void) => () => void;
}

interface UseReconnectionOptions extends ReconnectionConfig {
    enabled?: boolean;
    autoConnect?: boolean;
}
interface UseReconnectionReturn {
    status: ConnectionStatus;
    retryCount: number;
    nextRetryDelay: number;
    connect: () => Promise<void>;
    disconnect: (reason?: string) => void;
    resetRetries: () => void;
}
declare function useReconnection(connectFn: () => Promise<void>, options?: UseReconnectionOptions): UseReconnectionReturn;
interface UseWebSocketReconnectionOptions extends Omit<UseReconnectionOptions, 'onError'> {
    url: string;
    protocols?: string | string[];
    enableHeartbeat?: boolean;
    pingInterval?: number;
    pongTimeout?: number;
    onMessage?: (event: MessageEvent) => void;
    onOpen?: (event: Event) => void;
    onClose?: (event: CloseEvent) => void;
    onError?: (error: Error, retryCount: number) => void;
    onWebSocketError?: (event: Event) => void;
}
interface UseWebSocketReconnectionReturn extends UseReconnectionReturn {
    ws: WebSocket | undefined;
    send: (data: string | ArrayBuffer | Blob) => void;
    close: (code?: number, reason?: string) => void;
}
declare function useWebSocketReconnection(options: UseWebSocketReconnectionOptions): UseWebSocketReconnectionReturn;
declare function useChartDataStream(symbol: string, timeframe: string, onCandle: (candle: ChartData$1) => void): {
    status: ConnectionStatus;
    retryCount: number;
};

interface WebSocketConfig {
    url: string;
    apiKey?: string;
    broker?: string;
    enableHeartbeat?: boolean;
    pingInterval?: number;
    pongTimeout?: number;
    maxRetries?: number;
    initialDelay?: number;
    maxDelay?: number;
}
interface StreamMessage {
    type: 'candle' | 'trade' | 'error' | 'subscribed' | 'unsubscribed';
    symbol?: string;
    timeframe?: string;
    data?: any;
    error?: string;
}
interface CandleUpdate {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number;
}
interface Subscription {
    symbol: string;
    timeframe: string;
    callback: (candle: ChartData$1) => void;
    onRawMessage?: (message: any) => void;
}
declare class WebSocketService {
    private manager?;
    private subscriptions;
    private config;
    private isConnected;
    constructor(config: WebSocketConfig);
    connect(): Promise<void>;
    private sendAuthMessage;
    private resubscribeAll;
    private handleMessage;
    private handleCandleUpdate;
    subscribe(symbol: string, timeframe: string, callback: (candle: ChartData$1) => void, onRawMessage?: (message: any) => void): () => void;
    unsubscribe(symbol: string, timeframe: string): void;
    private sendSubscribeMessage;
    private sendUnsubscribeMessage;
    private send;
    private getSubscriptionKey;
    disconnect(): void;
    getStatus(): ConnectionStatus;
    getRetryCount(): number;
    isConnectedStatus(): boolean;
}
declare function getWebSocketService(config?: WebSocketConfig): WebSocketService;
declare function destroyWebSocketService(): void;

interface UseWebSocketDataProps {
    symbol: string;
    timeframe: string;
    wsConfig: WebSocketConfig;
    onUpdate?: (candle: ChartData$1) => void;
    onRawMessage?: (message: any) => void;
    enabled?: boolean;
}
interface UseWebSocketDataReturn {
    status: 'disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'failed';
    retryCount: number;
    lastUpdate?: ChartData$1;
    connect: () => Promise<void>;
    disconnect: () => void;
}
declare function useWebSocketData({ symbol, timeframe, wsConfig, onUpdate, onRawMessage, enabled }: UseWebSocketDataProps): UseWebSocketDataReturn;

interface ChartData {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}
interface FetchOptions {
    forceRefresh?: boolean;
    range?: {
        from: number;
        to: number;
    };
}
interface SymbolMetadata {
    data_from: number;
    data_to: number;
    total_ticks?: number;
}
declare class ChartDataCoordinator {
    private cache;
    private pendingRequests;
    private defaultRanges;
    private metadataCache;
    private cacheTimeout;
    private logger;
    private useHTTP;
    private requestStats;
    private normalizationFactors;
    /**
     * Get or set the default range for a symbol-timeframe combination
     */
    setDefaultRange(symbol: string, timeframe: string, from: number, to: number): void;
    /**
     * Generate cache key matching backend logic
     */
    private getCacheKey;
    /**
     * Check if cached data is still valid
     */
    private isCacheValid;
    /**
     * Calculate default range based on timeframe and available data
     * Uses FULL data range for ALL timeframes to ensure smooth transitions
     */
    private calculateDefaultRange;
    /**
     * Main method to fetch chart data with coordination
     */
    fetchChartData(symbol: string, timeframe: string, options?: FetchOptions): Promise<ChartData[]>;
    /**
     * Enable HTTP data provider
     */
    enableHTTP(enable?: boolean): void;
    /**
     * Perform the actual backend fetch
     */
    private doFetch;
    /**
     * Get metadata for a symbol
     */
    getSymbolMetadata(symbol: string): Promise<SymbolMetadata | null>;
    /**
     * Invalidate cache entries
     */
    invalidateCache(pattern?: string): void;
    /**
     * Cancel all pending requests
     */
    cancelPendingRequests(): void;
    /**
     * Get cache statistics
     */
    getCacheStats(): {
        cacheSize: number;
        pendingRequests: number;
        defaultRanges: number;
        requestStats: {
            totalRequests: number;
            cacheHits: number;
            cacheMisses: number;
            pendingReuse: number;
            backendCalls: number;
        };
    };
    /**
     * Get request statistics for debugging
     */
    getRequestStats(): {
        cacheHitRate: string;
        duplicatesAvoided: number;
        totalRequests: number;
        cacheHits: number;
        cacheMisses: number;
        pendingReuse: number;
        backendCalls: number;
    };
    /**
     * Reset request statistics
     */
    resetRequestStats(): void;
}
declare const chartDataCoordinator: ChartDataCoordinator;

interface HTTPDataProviderConfig {
    baseUrl: string;
    apiKey?: string;
    timeout?: number;
}
interface FetchCandlesParams {
    symbol: string;
    timeframe: string;
    from: number;
    to: number;
}
declare class HTTPDataProvider {
    private config;
    private logger;
    constructor(config: HTTPDataProviderConfig);
    /**
     * Fetch historical candles from the API
     */
    fetchCandles(params: FetchCandlesParams): Promise<Candle[]>;
    /**
     * Fetch metadata for a symbol (date range info)
     */
    fetchMetadata(symbol: string): Promise<{
        earliest: number;
        latest: number;
    }>;
    /**
     * Update configuration
     */
    updateConfig(config: Partial<HTTPDataProviderConfig>): void;
    /**
     * Get current configuration (without sensitive data)
     */
    getConfig(): {
        baseUrl: string;
        timeout: number | undefined;
        hasApiKey: boolean;
    };
}
/**
 * Get or create the HTTPDataProvider singleton
 */
declare function getHTTPDataProvider(config?: HTTPDataProviderConfig): HTTPDataProvider;
/**
 * Destroy the singleton instance
 */
declare function destroyHTTPDataProvider(): void;

declare const invoke: <T = unknown>(cmd: string, args?: Record<string, unknown>) => Promise<T>;
declare const listen: <T = unknown>(event: string, handler: (event: {
    payload: T;
}) => void) => Promise<() => void>;

interface RequestMetrics {
    timestamp: number;
    symbol: string;
    timeframe: string;
    from: number;
    to: number;
    candlesReturned: number;
    cacheHit: boolean;
    latencyMs: number;
    bytesEstimate: number;
}
interface MetricsSummary {
    totalRequests: number;
    cacheHits: number;
    cacheMisses: number;
    cacheHitRate: number;
    totalCandles: number;
    totalBytesEstimate: number;
    averageLatencyMs: number;
    byTimeframe: Record<string, {
        requests: number;
        candles: number;
        avgCandlesPerRequest: number;
        bytesEstimate: number;
    }>;
    bySymbol: Record<string, {
        requests: number;
        candles: number;
        bytesEstimate: number;
    }>;
    requestLog: RequestMetrics[];
}
declare const getMetricsSummary: () => MetricsSummary;
declare const printMetricsSummary: () => void;
declare const resetMetrics: () => void;
declare const mockInvoke: <T = unknown>(cmd: string, args?: Record<string, unknown>) => Promise<T>;
declare const mockListen: <T = unknown>(event: string, handler: (payload: T) => void) => Promise<() => void>;

interface CachedData {
    candles: ChartData$1[];
    timestamp: number;
}
interface MetadataCache {
    [symbol: string]: {
        from: number;
        to: number;
        timestamp: number;
    };
}
interface ChartState {
    candleCache: Map<string, CachedData>;
    viewStates: Map<string, ViewState>;
    metadataCache: MetadataCache;
    isLoading: boolean;
    currentSymbol: string;
    currentTimeframe: string;
    setLoading: (loading: boolean) => void;
    setCurrentSymbol: (symbol: string) => void;
    setCurrentTimeframe: (timeframe: string) => void;
    getCachedCandles: (key: string) => ChartData$1[] | null;
    setCachedCandles: (key: string, candles: ChartData$1[]) => void;
    invalidateCache: (pattern?: string) => void;
    getCachedMetadata: (symbol: string) => {
        from: number;
        to: number;
    } | null;
    setCachedMetadata: (symbol: string, from: number, to: number) => void;
    saveViewState: (symbol: string, state: ViewState) => void;
    getViewState: (symbol: string) => ViewState | null;
    getCacheKey: (symbol: string, timeframe: string, from: number, to: number) => string;
}
declare const useChartStore: zustand.UseBoundStore<Omit<zustand.StoreApi<ChartState>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: ChartState | Partial<ChartState> | ((state: ChartState) => ChartState | Partial<ChartState>), replace?: boolean | undefined, action?: A | undefined): void;
}>;

interface TradingStore {
    selectedPair: string;
    setSelectedPair: (pair: string) => void;
}
declare const useTradingStore: zustand.UseBoundStore<zustand.StoreApi<TradingStore>>;

/**
 * Timeframe period durations in seconds
 */
declare const TIMEFRAME_SECONDS: {
    readonly '5m': number;
    readonly '15m': number;
    readonly '1h': number;
    readonly '4h': number;
    readonly '12h': number;
};
/**
 * All available timeframes for preloading
 */
declare const ALL_TIMEFRAMES: readonly ["5m", "15m", "1h", "4h", "12h"];
/**
 * Valid timeframe keys
 */
type Timeframe = keyof typeof TIMEFRAME_SECONDS;
/**
 * Default timeframe when none is specified
 */
declare const DEFAULT_TIMEFRAME: Timeframe;
/**
 * Get the period duration in seconds for a timeframe
 */
declare function getTimeframePeriodSeconds(timeframe: string): number;
/**
 * Bar spacing thresholds for automatic timeframe switching
 * zoomOut: When bar spacing goes below this value, switch to longer timeframe
 * zoomIn: When bar spacing goes above this value, switch to shorter timeframe
 */
declare const TIMEFRAME_SWITCH_THRESHOLDS: {
    readonly '5m': {
        readonly zoomOut: 5;
        readonly zoomIn: 40;
    };
    readonly '15m': {
        readonly zoomOut: 5;
        readonly zoomIn: 40;
    };
    readonly '1h': {
        readonly zoomOut: 5;
        readonly zoomIn: 40;
    };
    readonly '4h': {
        readonly zoomOut: 3;
        readonly zoomIn: 40;
    };
    readonly '12h': {
        readonly zoomOut: 3;
        readonly zoomIn: 30;
    };
};
/**
 * Adjacent timeframes for preloading
 * Maps each timeframe to the timeframes you'd likely switch to (zoom in/out)
 */
declare const ADJACENT_TIMEFRAMES: Record<string, string[]>;

/**
 * Calculate the appropriate bar spacing when switching timeframes
 * Maintains visual continuity during transitions
 */
declare function calculateBarSpacingForTimeframeSwitch(currentBarSpacing: number, fromTimeframe: string, toTimeframe: string): number;
/**
 * Calculate days to show based on timeframe
 * Used for initial chart view
 */
declare function getDaysToShowForTimeframe(timeframe: string): number;
/**
 * Set the visible range to show a specific number of days
 */
declare function setVisibleRangeByDays(chart: IChartApi, days: number): void;
/**
 * Get the current visible range duration in seconds
 */
declare function getVisibleRangeDuration(chart: IChartApi): number;
/**
 * Check if a specific time is visible on the chart
 */
declare function isTimeVisible(chart: IChartApi, time: number): boolean;
/**
 * Scroll to a specific time, optionally centering it
 */
declare function scrollToTime(chart: IChartApi, time: number, center?: boolean): void;
/**
 * Find the last real candle (non-placeholder) in series data
 */
declare function findLastRealCandle(series: ISeriesApi<'Candlestick'>): CandlestickData | null;
/**
 * Create a placeholder candle for the current time period
 */
declare function createPlaceholderCandle(lastCandle: CandlestickData | null, timeframe: string, currentTime: number): CandlestickData;

declare enum LogLevel {
    ERROR = 0,
    WARN = 1,
    INFO = 2,
    DEBUG = 3,
    TRACE = 4
}
interface LoggerConfig {
    level: LogLevel;
    prefix?: string;
    enableTimestamp?: boolean;
    enableColors?: boolean;
    customHandler?: (level: LogLevel, message: string, ...args: unknown[]) => void;
}
declare class Logger {
    private config;
    private colors;
    configure(config: Partial<LoggerConfig>): void;
    private shouldLog;
    private formatMessage;
    private log;
    error(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    trace(message: string, ...args: unknown[]): void;
    child(prefix: string): Logger;
}
declare const logger: Logger;
declare const createLogger: (prefix: string) => Logger;

interface MarketChartPageProps {
    symbol?: string;
    timeframe?: string;
    enableTimeframeAutoSwitch?: boolean;
}
declare const MarketChartPage: ({ symbol, enableTimeframeAutoSwitch }?: MarketChartPageProps) => react_jsx_runtime.JSX.Element;

declare const getChartRequestStats: () => {
    cacheHitRate: string;
    duplicatesAvoided: number;
    totalRequests: number;
    cacheHits: number;
    cacheMisses: number;
    pendingReuse: number;
    backendCalls: number;
};
declare const resetChartRequestStats: () => void;

export { ADJACENT_TIMEFRAMES, ALL_TIMEFRAMES, type Candle, type CandleUpdate, type ChartConfig, type ChartData$1 as ChartData, ChartDataCoordinator, ChartEmptyState, ChartErrorBoundary, ChartLoadingState, ChartSkeleton, type ChartTheme, type ConnectionStatus, CountdownTimerPrimitive, DEFAULT_TIMEFRAME, type DataProvider, type DataRequest, EmptyState, ErrorBoundary, type FetchCandlesArgs, HTTPDataProvider, InlineLoader, LoadingState, LogLevel, type LoggerConfig, MarketChartPage, MarketDataChart, MinimalStreamStatus, NoDataInRangeState, type ReconnectionConfig, ReconnectionManager, type StreamMessage, StreamStatus, type StreamStatusData, type Subscription, type SymbolMetadata, TIMEFRAME_SECONDS, TIMEFRAME_SWITCH_THRESHOLDS, type Tick, type Timeframe, TimeframeWatermarkPrimitive, type UseChartSetupOptions, type UseChartSetupReturn, type UseChartZoomOptions, type UseChartZoomReturn, type UseCountdownTimerOptions, type UseCountdownTimerReturn, type UsePlaceholderCandleOptions, type UsePlaceholderCandleReturn, type UseReconnectionOptions, type UseReconnectionReturn, type UseWebSocketDataProps, type UseWebSocketDataReturn, type UseWebSocketReconnectionOptions, type UseWebSocketReconnectionReturn, type ViewState, type VisibleRange, type WebSocketConfig, WebSocketReconnectionManager, WebSocketService, calculateBarSpacingForTimeframeSwitch, calculateCandleTime, chartDataCoordinator, createLogger, createPlaceholderCandle, darkTheme, defaultChartOptions, defaultSeriesOptions, destroyHTTPDataProvider, destroyWebSocketService, findLastRealCandle, getChartRequestStats, getCurrentCandleTime, getDaysToShowForTimeframe, getHTTPDataProvider, getMetricsSummary, getNextCandleTime, getTimeframePeriodSeconds, getVisibleRangeDuration, getWebSocketService, invoke, isTimeVisible, listen, logger, mockInvoke, mockListen, printMetricsSummary, resetChartRequestStats, resetMetrics, scrollToTime, setVisibleRangeByDays, useChartData, useChartDataStream, useChartSetup, useChartStore, useChartZoom, useCountdownTimer, usePlaceholderCandle, useReconnection, useTradingStore, useWebSocketData, useWebSocketReconnection };
