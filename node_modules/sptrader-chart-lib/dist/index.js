'use strict';

var React3 = require('react');
var lightweightCharts = require('lightweight-charts');
var zustand = require('zustand');
var middleware = require('zustand/middleware');
var core = require('@mantine/core');
var jsxRuntime = require('react/jsx-runtime');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React3__default = /*#__PURE__*/_interopDefault(React3);

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/@tauri-apps/api/external/tslib/tslib.es6.js
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
var init_tslib_es6 = __esm({
  "node_modules/@tauri-apps/api/external/tslib/tslib.es6.js"() {
  }
});

// node_modules/@tauri-apps/api/core.js
var core_exports = {};
__export(core_exports, {
  Channel: () => Channel,
  PluginListener: () => PluginListener,
  Resource: () => Resource,
  SERIALIZE_TO_IPC_FN: () => SERIALIZE_TO_IPC_FN,
  addPluginListener: () => addPluginListener,
  checkPermissions: () => checkPermissions,
  convertFileSrc: () => convertFileSrc,
  invoke: () => invoke,
  isTauri: () => isTauri,
  requestPermissions: () => requestPermissions,
  transformCallback: () => transformCallback
});
function transformCallback(callback, once2 = false) {
  return window.__TAURI_INTERNALS__.transformCallback(callback, once2);
}
async function addPluginListener(plugin, event, cb) {
  const handler = new Channel(cb);
  try {
    return invoke(`plugin:${plugin}|register_listener`, {
      event,
      handler
    }).then(() => new PluginListener(plugin, event, handler.id));
  } catch {
    return invoke(`plugin:${plugin}|registerListener`, { event, handler }).then(() => new PluginListener(plugin, event, handler.id));
  }
}
async function checkPermissions(plugin) {
  return invoke(`plugin:${plugin}|check_permissions`);
}
async function requestPermissions(plugin) {
  return invoke(`plugin:${plugin}|request_permissions`);
}
async function invoke(cmd, args = {}, options) {
  return window.__TAURI_INTERNALS__.invoke(cmd, args, options);
}
function convertFileSrc(filePath, protocol = "asset") {
  return window.__TAURI_INTERNALS__.convertFileSrc(filePath, protocol);
}
function isTauri() {
  return !!(globalThis || window).isTauri;
}
var _Channel_onmessage, _Channel_nextMessageIndex, _Channel_pendingMessages, _Channel_messageEndIndex, _Resource_rid, SERIALIZE_TO_IPC_FN, Channel, PluginListener, Resource;
var init_core = __esm({
  "node_modules/@tauri-apps/api/core.js"() {
    init_tslib_es6();
    SERIALIZE_TO_IPC_FN = "__TAURI_TO_IPC_KEY__";
    Channel = class {
      constructor(onmessage) {
        _Channel_onmessage.set(this, void 0);
        _Channel_nextMessageIndex.set(this, 0);
        _Channel_pendingMessages.set(this, []);
        _Channel_messageEndIndex.set(this, void 0);
        __classPrivateFieldSet(this, _Channel_onmessage, onmessage || (() => {
        }));
        this.id = transformCallback((rawMessage) => {
          const index = rawMessage.index;
          if ("end" in rawMessage) {
            if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, "f")) {
              this.cleanupCallback();
            } else {
              __classPrivateFieldSet(this, _Channel_messageEndIndex, index);
            }
            return;
          }
          const message = rawMessage.message;
          if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, "f")) {
            __classPrivateFieldGet(this, _Channel_onmessage, "f").call(this, message);
            __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, "f") + 1);
            while (__classPrivateFieldGet(this, _Channel_nextMessageIndex, "f") in __classPrivateFieldGet(this, _Channel_pendingMessages, "f")) {
              const message2 = __classPrivateFieldGet(this, _Channel_pendingMessages, "f")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, "f")];
              __classPrivateFieldGet(this, _Channel_onmessage, "f").call(this, message2);
              delete __classPrivateFieldGet(this, _Channel_pendingMessages, "f")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, "f")];
              __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, "f") + 1);
            }
            if (__classPrivateFieldGet(this, _Channel_nextMessageIndex, "f") === __classPrivateFieldGet(this, _Channel_messageEndIndex, "f")) {
              this.cleanupCallback();
            }
          } else {
            __classPrivateFieldGet(this, _Channel_pendingMessages, "f")[index] = message;
          }
        });
      }
      cleanupCallback() {
        window.__TAURI_INTERNALS__.unregisterCallback(this.id);
      }
      set onmessage(handler) {
        __classPrivateFieldSet(this, _Channel_onmessage, handler);
      }
      get onmessage() {
        return __classPrivateFieldGet(this, _Channel_onmessage, "f");
      }
      [(_Channel_onmessage = /* @__PURE__ */ new WeakMap(), _Channel_nextMessageIndex = /* @__PURE__ */ new WeakMap(), _Channel_pendingMessages = /* @__PURE__ */ new WeakMap(), _Channel_messageEndIndex = /* @__PURE__ */ new WeakMap(), SERIALIZE_TO_IPC_FN)]() {
        return `__CHANNEL__:${this.id}`;
      }
      toJSON() {
        return this[SERIALIZE_TO_IPC_FN]();
      }
    };
    PluginListener = class {
      constructor(plugin, event, channelId) {
        this.plugin = plugin;
        this.event = event;
        this.channelId = channelId;
      }
      async unregister() {
        return invoke(`plugin:${this.plugin}|remove_listener`, {
          event: this.event,
          channelId: this.channelId
        });
      }
    };
    Resource = class {
      get rid() {
        return __classPrivateFieldGet(this, _Resource_rid, "f");
      }
      constructor(rid) {
        _Resource_rid.set(this, void 0);
        __classPrivateFieldSet(this, _Resource_rid, rid);
      }
      /**
       * Destroys and cleans up this resource from memory.
       * **You should not call any method on this object anymore and should drop any reference to it.**
       */
      async close() {
        return invoke("plugin:resources|close", {
          rid: this.rid
        });
      }
    };
    _Resource_rid = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@tauri-apps/api/event.js
var event_exports = {};
__export(event_exports, {
  TauriEvent: () => TauriEvent,
  emit: () => emit,
  emitTo: () => emitTo,
  listen: () => listen,
  once: () => once
});
async function _unlisten(event, eventId) {
  window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener(event, eventId);
  await invoke("plugin:event|unlisten", {
    event,
    eventId
  });
}
async function listen(event, handler, options) {
  var _a;
  const target = typeof (options === null || options === void 0 ? void 0 : options.target) === "string" ? { kind: "AnyLabel", label: options.target } : (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : { kind: "Any" };
  return invoke("plugin:event|listen", {
    event,
    target,
    handler: transformCallback(handler)
  }).then((eventId) => {
    return async () => _unlisten(event, eventId);
  });
}
async function once(event, handler, options) {
  return listen(event, (eventData) => {
    void _unlisten(event, eventData.id);
    handler(eventData);
  }, options);
}
async function emit(event, payload) {
  await invoke("plugin:event|emit", {
    event,
    payload
  });
}
async function emitTo(target, event, payload) {
  const eventTarget = typeof target === "string" ? { kind: "AnyLabel", label: target } : target;
  await invoke("plugin:event|emit_to", {
    target: eventTarget,
    event,
    payload
  });
}
var TauriEvent;
var init_event = __esm({
  "node_modules/@tauri-apps/api/event.js"() {
    init_core();
    (function(TauriEvent2) {
      TauriEvent2["WINDOW_RESIZED"] = "tauri://resize";
      TauriEvent2["WINDOW_MOVED"] = "tauri://move";
      TauriEvent2["WINDOW_CLOSE_REQUESTED"] = "tauri://close-requested";
      TauriEvent2["WINDOW_DESTROYED"] = "tauri://destroyed";
      TauriEvent2["WINDOW_FOCUS"] = "tauri://focus";
      TauriEvent2["WINDOW_BLUR"] = "tauri://blur";
      TauriEvent2["WINDOW_SCALE_FACTOR_CHANGED"] = "tauri://scale-change";
      TauriEvent2["WINDOW_THEME_CHANGED"] = "tauri://theme-changed";
      TauriEvent2["WINDOW_CREATED"] = "tauri://window-created";
      TauriEvent2["WEBVIEW_CREATED"] = "tauri://webview-created";
      TauriEvent2["DRAG_ENTER"] = "tauri://drag-enter";
      TauriEvent2["DRAG_OVER"] = "tauri://drag-over";
      TauriEvent2["DRAG_DROP"] = "tauri://drag-drop";
      TauriEvent2["DRAG_LEAVE"] = "tauri://drag-leave";
    })(TauriEvent || (TauriEvent = {}));
  }
});

// src/utils/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["ERROR"] = 0] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 1] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 3] = "DEBUG";
  LogLevel2[LogLevel2["TRACE"] = 4] = "TRACE";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  constructor() {
    this.config = {
      level: 0 /* ERROR */,
      // Only show errors, suppress INFO/DEBUG/TRACE
      enableTimestamp: true,
      enableColors: true
    };
    this.colors = {
      [0 /* ERROR */]: "\x1B[31m",
      // Red
      [1 /* WARN */]: "\x1B[33m",
      // Yellow
      [2 /* INFO */]: "\x1B[36m",
      // Cyan
      [3 /* DEBUG */]: "\x1B[90m",
      // Gray
      [4 /* TRACE */]: "\x1B[37m",
      // White
      reset: "\x1B[0m"
    };
  }
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  shouldLog(level) {
    if (typeof window !== "undefined" && window.__CHART_LOG_LEVEL__) {
      const dynamicLevel = LogLevel[window.__CHART_LOG_LEVEL__];
      if (dynamicLevel !== void 0) {
        return level <= dynamicLevel;
      }
    }
    return level <= this.config.level;
  }
  formatMessage(level, message) {
    const parts = [];
    if (this.config.enableTimestamp) {
      parts.push(`[${(/* @__PURE__ */ new Date()).toISOString()}]`);
    }
    if (this.config.prefix) {
      parts.push(`[${this.config.prefix}]`);
    }
    parts.push(`[${LogLevel[level]}]`);
    parts.push(message);
    return parts.join(" ");
  }
  log(level, message, ...args) {
    if (!this.shouldLog(level)) return;
    if (this.config.customHandler) {
      this.config.customHandler(level, message, ...args);
      return;
    }
    const formattedMessage = this.formatMessage(level, message);
    const logMethod = level === 0 /* ERROR */ ? console.error : level === 1 /* WARN */ ? console.warn : console.log;
    if (this.config.enableColors && typeof window === "undefined") {
      const color = this.colors[level];
      logMethod(`${color}${formattedMessage}${this.colors.reset}`, ...args);
    } else {
      logMethod(formattedMessage, ...args);
    }
  }
  error(message, ...args) {
    this.log(0 /* ERROR */, message, ...args);
  }
  warn(message, ...args) {
    this.log(1 /* WARN */, message, ...args);
  }
  info(message, ...args) {
    this.log(2 /* INFO */, message, ...args);
  }
  debug(message, ...args) {
    this.log(3 /* DEBUG */, message, ...args);
  }
  trace(message, ...args) {
    this.log(4 /* TRACE */, message, ...args);
  }
  // Create a child logger with a specific prefix
  child(prefix) {
    const childLogger = new _Logger();
    childLogger.configure({
      ...this.config,
      prefix: this.config.prefix ? `${this.config.prefix}:${prefix}` : prefix
    });
    return childLogger;
  }
};
var logger = new Logger();
if (typeof window !== "undefined") {
  const logLevel = window.__CHART_LOG_LEVEL__ ? LogLevel[window.__CHART_LOG_LEVEL__] || 2 /* INFO */ : process.env.NODE_ENV === "development" ? 2 /* INFO */ : 1 /* WARN */;
  logger.configure({ level: logLevel });
} else {
  const logLevel = process.env.LOG_LEVEL ? LogLevel[process.env.LOG_LEVEL] || 2 /* INFO */ : 2 /* INFO */;
  logger.configure({ level: logLevel });
}
var createLogger = (prefix) => logger.child(prefix);

// src/stores/useChartStore.ts
var CACHE_TTL = 10 * 60 * 1e3;
var logger2 = createLogger("useChartStore");
var useChartStore = zustand.create()(
  middleware.devtools(
    (set, get) => ({
      // Initial state
      candleCache: /* @__PURE__ */ new Map(),
      viewStates: /* @__PURE__ */ new Map(),
      metadataCache: {},
      isLoading: false,
      currentSymbol: "EURUSD",
      currentTimeframe: "1h",
      // Basic setters
      setLoading: (loading) => set({ isLoading: loading }),
      setCurrentSymbol: (symbol) => set({ currentSymbol: symbol }),
      setCurrentTimeframe: (timeframe) => set({ currentTimeframe: timeframe }),
      // Cache key generator - MUST match backend normalization
      getCacheKey: (symbol, timeframe, from, to) => {
        const normalizationFactor = {
          "1m": 300,
          // 5 minutes
          "5m": 900,
          // 15 minutes
          "15m": 3600,
          // 1 hour
          "1h": 7200,
          // 2 hours
          "4h": 14400,
          // 4 hours
          "12h": 43200
          // 12 hours
        };
        const factor = normalizationFactor[timeframe] || 3600;
        const normalizedFrom = Math.floor(from / factor) * factor;
        const normalizedTo = Math.floor(to / factor) * factor;
        return `${symbol}-${timeframe}-${normalizedFrom}-${normalizedTo}`;
      },
      // Get cached candles
      getCachedCandles: (key) => {
        const cached = get().candleCache.get(key);
        if (!cached) {
          logger2.debug("Cache miss for:", key);
          logger2.debug("Current cache keys:", Array.from(get().candleCache.keys()));
          return null;
        }
        const now = Date.now();
        const age = now - cached.timestamp;
        if (age > CACHE_TTL) {
          logger2.debug("Cache expired for:", key, {
            age: `${(age / 1e3).toFixed(0)}s`,
            ttl: `${(CACHE_TTL / 1e3).toFixed(0)}s`,
            cachedAt: new Date(cached.timestamp).toISOString(),
            now: new Date(now).toISOString()
          });
          const newCache = new Map(get().candleCache);
          newCache.delete(key);
          set({ candleCache: newCache });
          return null;
        }
        logger2.debug(
          "Cache hit for:",
          key,
          `(${cached.candles.length} candles, age: ${(age / 1e3).toFixed(0)}s)`
        );
        return cached.candles;
      },
      // Set cached candles
      setCachedCandles: (key, candles) => {
        const newCache = new Map(get().candleCache);
        if (newCache.size >= 100) {
          const entries = Array.from(newCache.entries()).sort(
            (a, b) => a[1].timestamp - b[1].timestamp
          );
          if (entries.length > 0 && entries[0]) {
            const oldestKey = entries[0][0];
            newCache.delete(oldestKey);
            logger2.info("Cache eviction, removed:", oldestKey);
          }
        }
        newCache.set(key, {
          candles,
          timestamp: Date.now()
        });
        logger2.debug("Cached", candles.length, "candles for:", key);
        set({ candleCache: newCache });
      },
      // Invalidate cache
      invalidateCache: (pattern) => {
        const cache = get().candleCache;
        if (!pattern) {
          logger2.info("Clearing entire cache");
          set({ candleCache: /* @__PURE__ */ new Map() });
          return;
        }
        const newCache = new Map(cache);
        let removed = 0;
        cache.forEach((_, key) => {
          if (key.includes(pattern)) {
            newCache.delete(key);
            removed++;
          }
        });
        logger2.info(`Invalidated ${removed} cache entries matching:`, pattern);
        set({ candleCache: newCache });
      },
      // Save view state
      saveViewState: (symbol, state) => {
        const newViewStates = new Map(get().viewStates);
        newViewStates.set(symbol, state);
        logger2.debug("Saved view state for:", symbol, state);
        set({ viewStates: newViewStates });
      },
      // Get view state
      getViewState: (symbol) => {
        const state = get().viewStates.get(symbol);
        if (state) {
          logger2.debug("Retrieved view state for:", symbol, state);
        }
        return state || null;
      },
      // Get cached metadata
      getCachedMetadata: (symbol) => {
        const cached = get().metadataCache[symbol];
        if (!cached) {
          logger2.debug(
            "Metadata cache miss for:",
            symbol,
            "Available keys:",
            Object.keys(get().metadataCache)
          );
          return null;
        }
        const now = Date.now();
        const age = now - cached.timestamp;
        if (age > CACHE_TTL) {
          logger2.debug(
            "Metadata cache expired for:",
            symbol,
            `age: ${(age / 1e3).toFixed(0)}s`
          );
          const newCache = { ...get().metadataCache };
          delete newCache[symbol];
          set({ metadataCache: newCache });
          return null;
        }
        logger2.debug("Metadata cache hit for:", symbol);
        return { from: cached.from, to: cached.to };
      },
      // Set cached metadata
      setCachedMetadata: (symbol, from, to) => {
        const newCache = {
          ...get().metadataCache,
          [symbol]: {
            from,
            to,
            timestamp: Date.now()
          }
        };
        logger2.debug("Cached metadata for:", symbol, { from, to });
        set({ metadataCache: newCache });
      }
    }),
    {
      name: "chart-store"
    }
  )
);

// src/services/mockTauriApi.ts
var logger3 = createLogger("MockTauriApi");
var candleCache = /* @__PURE__ */ new Map();
var CACHE_TTL2 = 5 * 60 * 1e3;
var requestMetrics = [];
var simulateNetworkLatency = async () => {
  return 0;
};
var estimateCandleBytes = (_candle) => {
  return 68;
};
var recordRequest = (symbol, timeframe, from, to, candles, cacheHit, latencyMs) => {
  const bytesEstimate = candles.length * estimateCandleBytes(candles[0] || {
    });
  const metric = {
    timestamp: Date.now(),
    symbol,
    timeframe,
    from,
    to,
    candlesReturned: candles.length,
    cacheHit,
    latencyMs,
    bytesEstimate
  };
  requestMetrics.push(metric);
  logger3.info(
    `[METRICS] ${cacheHit ? "CACHE HIT" : "CACHE MISS"} | ${symbol} ${timeframe} | ${candles.length} candles | ~${(bytesEstimate / 1024).toFixed(2)} KB | ${latencyMs.toFixed(0)}ms`
  );
};
var getMetricsSummary = () => {
  if (requestMetrics.length === 0) {
    return {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      cacheHitRate: 0,
      totalCandles: 0,
      totalBytesEstimate: 0,
      averageLatencyMs: 0,
      byTimeframe: {},
      bySymbol: {},
      requestLog: []
    };
  }
  const cacheHits = requestMetrics.filter((m) => m.cacheHit).length;
  const cacheMisses = requestMetrics.length - cacheHits;
  const totalCandles = requestMetrics.reduce((sum, m) => sum + m.candlesReturned, 0);
  const totalBytes = requestMetrics.reduce((sum, m) => sum + m.bytesEstimate, 0);
  const avgLatency = requestMetrics.reduce((sum, m) => sum + m.latencyMs, 0) / requestMetrics.length;
  const byTimeframe = {};
  requestMetrics.forEach((m) => {
    if (!byTimeframe[m.timeframe]) {
      byTimeframe[m.timeframe] = { requests: 0, candles: 0, avgCandlesPerRequest: 0, bytesEstimate: 0 };
    }
    const tf = byTimeframe[m.timeframe];
    if (tf) {
      tf.requests++;
      tf.candles += m.candlesReturned;
      tf.bytesEstimate += m.bytesEstimate;
    }
  });
  Object.keys(byTimeframe).forEach((tf) => {
    const stats = byTimeframe[tf];
    if (stats) {
      stats.avgCandlesPerRequest = stats.candles / stats.requests;
    }
  });
  const bySymbol = {};
  requestMetrics.forEach((m) => {
    if (!bySymbol[m.symbol]) {
      bySymbol[m.symbol] = { requests: 0, candles: 0, bytesEstimate: 0 };
    }
    const sym = bySymbol[m.symbol];
    if (sym) {
      sym.requests++;
      sym.candles += m.candlesReturned;
      sym.bytesEstimate += m.bytesEstimate;
    }
  });
  return {
    totalRequests: requestMetrics.length,
    cacheHits,
    cacheMisses,
    cacheHitRate: cacheHits / requestMetrics.length * 100,
    totalCandles,
    totalBytesEstimate: totalBytes,
    averageLatencyMs: avgLatency,
    byTimeframe,
    bySymbol,
    requestLog: [...requestMetrics]
    // Return a copy
  };
};
var printMetricsSummary = () => {
  const summary = getMetricsSummary();
  console.log("\n" + "=".repeat(80));
  console.log("\u{1F4CA} MOCK API METRICS SUMMARY");
  console.log("=".repeat(80));
  console.log("\n\u{1F4C8} OVERALL STATISTICS:");
  console.log(`  Total Requests:        ${summary.totalRequests}`);
  console.log(`  Cache Hits:            ${summary.cacheHits} (${summary.cacheHitRate.toFixed(1)}%)`);
  console.log(`  Cache Misses:          ${summary.cacheMisses}`);
  console.log(`  Total Candles:         ${summary.totalCandles.toLocaleString()}`);
  console.log(`  Total Data Volume:     ~${(summary.totalBytesEstimate / 1024).toFixed(2)} KB`);
  console.log(`  Average Latency:       ${summary.averageLatencyMs.toFixed(0)}ms`);
  console.log("\n\u{1F4CA} BY TIMEFRAME:");
  Object.entries(summary.byTimeframe).sort(([, a], [, b]) => b.requests - a.requests).forEach(([timeframe, stats]) => {
    console.log(`  ${timeframe.padEnd(6)} - ${stats.requests} requests | ${stats.candles.toLocaleString()} candles | avg ${Math.round(stats.avgCandlesPerRequest)} candles/req | ~${(stats.bytesEstimate / 1024).toFixed(2)} KB`);
  });
  console.log("\n\u{1F3AF} BY SYMBOL:");
  Object.entries(summary.bySymbol).sort(([, a], [, b]) => b.requests - a.requests).forEach(([symbol, stats]) => {
    console.log(`  ${symbol.padEnd(10)} - ${stats.requests} requests | ${stats.candles.toLocaleString()} candles | ~${(stats.bytesEstimate / 1024).toFixed(2)} KB`);
  });
  console.log("\n" + "=".repeat(80) + "\n");
};
var resetMetrics = () => {
  requestMetrics.length = 0;
  logger3.info("[METRICS] Reset all metrics");
};
var getBasePrice = (symbol) => {
  if (symbol.includes("BTC")) return 112700;
  if (symbol.includes("ETH")) return 3800;
  if (symbol.includes("SOL")) return 220;
  return 1.08;
};
var getVolatility = (symbol) => {
  return symbol.includes("BTC") || symbol.includes("ETH") || symbol.includes("SOL") ? 1e-3 : 1e-4;
};
var generateDeterministicPrice = (basePrice, volatility, daySeed, offset) => {
  const trend = Math.sin(daySeed / 30) * basePrice * volatility * 2;
  const daily = Math.sin(daySeed) * basePrice * volatility;
  const micro = Math.sin((daySeed + offset) * 12.9898) * 43758.5453;
  const noise = (micro - Math.floor(micro) - 0.5) * basePrice * volatility * 0.5;
  return basePrice + trend + daily + noise;
};
var getCacheKey = (symbol, timeframe, from, to) => {
  return `${symbol}-${timeframe}-${from}-${to}`;
};
var alignToCandleBoundary = (timestamp, interval) => {
  if (interval === 14400) {
    const date = new Date(timestamp * 1e3);
    const hours = date.getUTCHours();
    const alignedHours = Math.floor(hours / 4) * 4;
    date.setUTCHours(alignedHours, 0, 0, 0);
    return Math.floor(date.getTime() / 1e3);
  } else if (interval === 43200) {
    const date = new Date(timestamp * 1e3);
    const hours = date.getUTCHours();
    const alignedHours = hours < 12 ? 0 : 12;
    date.setUTCHours(alignedHours, 0, 0, 0);
    return Math.floor(date.getTime() / 1e3);
  }
  return Math.floor(timestamp / interval) * interval;
};
var generateCandlesHierarchical = (from, to, symbol, timeframe) => {
  const intervals = {
    "5m": 300,
    "15m": 900,
    "1h": 3600,
    "4h": 14400,
    "12h": 43200
  };
  const targetInterval = intervals[timeframe] || 3600;
  const baseInterval = 300;
  const basePrice = getBasePrice(symbol);
  const volatility = getVolatility(symbol);
  const base5mCandles = [];
  const alignedStart = alignToCandleBoundary(from, baseInterval);
  const alignedEnd = alignToCandleBoundary(to + targetInterval, baseInterval);
  for (let time = alignedStart; time < alignedEnd; time += baseInterval) {
    const seed = time / 86400;
    const open = generateDeterministicPrice(basePrice, volatility, seed, 0);
    const close = generateDeterministicPrice(basePrice, volatility, seed, 0.95);
    const high = generateDeterministicPrice(basePrice, volatility, seed, 0.3) * 1.0002;
    const low = generateDeterministicPrice(basePrice, volatility, seed, 0.6) * 0.9998;
    base5mCandles.push({
      time,
      open,
      high: Math.max(open, close, high),
      low: Math.min(open, close, low),
      close,
      volume: Math.floor(1e4 + Math.sin(seed * 123.456) * 5e3)
    });
  }
  if (targetInterval === baseInterval) {
    return base5mCandles.filter((c) => c.time >= from && c.time <= to);
  }
  const aggregated = [];
  const targetAlignedStart = alignToCandleBoundary(from, targetInterval);
  const targetAlignedEnd = alignToCandleBoundary(to + targetInterval, targetInterval);
  let baseIndex = 0;
  for (let time = targetAlignedStart; time < targetAlignedEnd; time += targetInterval) {
    while (baseIndex < base5mCandles.length) {
      const candle = base5mCandles[baseIndex];
      if (!candle || candle.time >= time) break;
      baseIndex++;
    }
    const subCandles = [];
    let idx = baseIndex;
    while (idx < base5mCandles.length) {
      const candle = base5mCandles[idx];
      if (!candle || candle.time >= time + targetInterval) break;
      subCandles.push(candle);
      idx++;
    }
    if (subCandles.length > 0) {
      const firstCandle = subCandles[0];
      const lastCandle = subCandles[subCandles.length - 1];
      aggregated.push({
        time,
        open: firstCandle.open,
        high: Math.max(...subCandles.map((c) => c.high)),
        low: Math.min(...subCandles.map((c) => c.low)),
        close: lastCandle.close,
        volume: subCandles.reduce((sum, c) => sum + (c.volume || 0), 0)
      });
    }
  }
  return aggregated.filter((c) => c.time >= from && c.time <= to);
};
var mockInvoke = async (cmd, args) => {
  logger3.debug(`Command: ${cmd}`, args);
  switch (cmd) {
    case "fetch_candles":
      if (!args || !("request" in args)) {
        throw new Error("Missing request parameter");
      }
      const { request } = args;
      const { symbol, timeframe, from } = request;
      const now = Math.floor(Date.now() / 1e3);
      const to = Math.min(request.to, now - 120);
      const cacheKey = getCacheKey(symbol, timeframe, from, to);
      const cached = candleCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL2) {
        logger3.info(`[CACHE HIT] Returning ${cached.candles.length} cached ${timeframe} candles for ${symbol}`);
        const latency2 = await simulateNetworkLatency();
        recordRequest(symbol, timeframe, from, to, cached.candles, true, latency2);
        return cached.candles;
      }
      logger3.info(`[CACHE MISS] Generating ${timeframe} candles for ${symbol}`);
      const latency = await simulateNetworkLatency();
      const candles = generateCandlesHierarchical(from, to, symbol, timeframe);
      candleCache.set(cacheKey, {
        candles,
        timestamp: Date.now()
      });
      recordRequest(symbol, timeframe, from, to, candles, false, latency);
      logger3.info(`Generated ${candles.length} ${timeframe} candles (cached for 5min)`);
      return candles;
    case "get_symbol_metadata":
      return {
        data_from: Date.now() / 1e3 - 365 * 24 * 60 * 60,
        // 1 year ago
        data_to: Date.now() / 1e3,
        total_ticks: 1e6
      };
    case "start_candle_monitor":
    case "stop_candle_monitor":
      return null;
    default:
      logger3.warn(`Unknown command: ${cmd}`);
      return null;
  }
};
var mockListen = async (event, handler) => {
  logger3.debug(`Listening to event: ${event}`);
  if (event.includes("candles-updated")) {
    const interval = setInterval(() => {
      const timeframe = event.split("-").pop();
      handler({
        symbol: "EURUSD",
        timeframe: timeframe || "1h",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }, 5e3);
    return () => {
      logger3.debug(`Stopped listening to event: ${event}`);
      clearInterval(interval);
    };
  }
  return () => {
    console.log(`[Mock Tauri] Stopped listening to event: ${event}`);
  };
};

// src/services/tauriWrapper.ts
var logger4 = createLogger("TauriWrapper");
var isTauri2 = () => {
  try {
    return window.__TAURI__ !== void 0 || window.__TAURI_INTERNALS__ !== void 0 || window.__TAURI_IPC__ !== void 0 || window.location.protocol === "tauri:" || window.location.protocol === "https:";
  } catch {
    return false;
  }
};
var invoke2 = async (cmd, args) => {
  if (isTauri2()) {
    const { invoke: tauriInvoke } = await Promise.resolve().then(() => (init_core(), core_exports));
    return tauriInvoke(cmd, args);
  } else {
    return mockInvoke(cmd, args);
  }
};
var listen2 = async (event, handler) => {
  if (isTauri2()) {
    const { listen: tauriListen } = await Promise.resolve().then(() => (init_event(), event_exports));
    return tauriListen(event, handler);
  } else {
    return mockListen(event, (payload) => handler({ payload }));
  }
};
if (isTauri2()) {
  logger4.info("Running in Tauri environment");
} else {
  logger4.info("Running in browser - using mock API");
}

// src/services/HTTPDataProvider.ts
var HTTPDataProvider = class {
  constructor(config) {
    this.logger = createLogger("HTTPDataProvider");
    this.config = {
      timeout: 3e4,
      // 30 second default timeout
      ...config
    };
  }
  /**
   * Fetch historical candles from the API
   */
  async fetchCandles(params) {
    const { symbol, timeframe, from, to } = params;
    const queryParams = new URLSearchParams({
      symbol,
      timeframe,
      from: from.toString(),
      to: to.toString()
    });
    const url = `${this.config.baseUrl}/api/candles?${queryParams}`;
    const startTime = performance.now();
    this.logger.info(`\u{1F4CA} Fetching candles: ${symbol} ${timeframe} [${from} - ${to}]`);
    this.logger.debug(`Full URL: ${url}`);
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
      const headers = {
        "Content-Type": "application/json"
      };
      if (this.config.apiKey) {
        headers["Authorization"] = `Bearer ${this.config.apiKey}`;
      }
      const response = await fetch(url, {
        method: "GET",
        headers,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        this.logger.error("Invalid response format: expected array", data);
        return [];
      }
      const badCandles = data.filter(
        (c) => c.time == null || c.open == null || c.high == null || c.low == null || c.close == null
      );
      if (badCandles.length > 0) {
        this.logger.error(`Found ${badCandles.length} bad candles in API response:`, badCandles.slice(0, 5));
      }
      const candles = data.filter((candle) => {
        const isValid = candle.time != null && candle.open != null && typeof candle.open === "number" && !isNaN(candle.open) && candle.high != null && typeof candle.high === "number" && !isNaN(candle.high) && candle.low != null && typeof candle.low === "number" && !isNaN(candle.low) && candle.close != null && typeof candle.close === "number" && !isNaN(candle.close);
        return isValid;
      }).map((candle) => ({
        time: candle.time,
        open: candle.open,
        high: candle.high,
        low: candle.low,
        close: candle.close
      }));
      const elapsed = ((performance.now() - startTime) / 1e3).toFixed(2);
      this.logger.info(`\u2705 Fetched ${candles.length} candles for ${symbol} ${timeframe} in ${elapsed}s`);
      return candles;
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          this.logger.error(`Request timeout after ${this.config.timeout}ms`);
          throw new Error("Request timeout");
        }
        this.logger.error("Fetch error:", error.message);
        throw error;
      }
      throw new Error("Unknown error fetching candles");
    }
  }
  /**
   * Fetch metadata for a symbol (date range info)
   */
  async fetchMetadata(symbol) {
    const url = `${this.config.baseUrl}/api/metadata?symbol=${symbol}`;
    this.logger.debug(`Fetching metadata for ${symbol}`);
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
      const headers = {
        "Content-Type": "application/json"
      };
      if (this.config.apiKey) {
        headers["Authorization"] = `Bearer ${this.config.apiKey}`;
      }
      const response = await fetch(url, {
        method: "GET",
        headers,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      if (!data.earliest || !data.latest) {
        this.logger.error("Invalid metadata format:", data);
        throw new Error("Invalid metadata response");
      }
      this.logger.info(`Metadata for ${symbol}: ${new Date(data.earliest * 1e3).toISOString()} to ${new Date(data.latest * 1e3).toISOString()}`);
      return {
        earliest: data.earliest,
        latest: data.latest
      };
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          this.logger.error(`Metadata request timeout after ${this.config.timeout}ms`);
          throw new Error("Metadata request timeout");
        }
        this.logger.error("Metadata fetch error:", error.message);
        throw error;
      }
      throw new Error("Unknown error fetching metadata");
    }
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    const safeConfig = {
      baseUrl: this.config.baseUrl,
      timeout: this.config.timeout,
      apiKey: this.config.apiKey ? "[REDACTED]" : void 0
    };
    this.logger.info("Configuration updated", safeConfig);
  }
  /**
   * Get current configuration (without sensitive data)
   */
  getConfig() {
    return {
      baseUrl: this.config.baseUrl,
      timeout: this.config.timeout,
      hasApiKey: !!this.config.apiKey
    };
  }
};
var httpDataProvider = null;
function getHTTPDataProvider(config) {
  if (!httpDataProvider && !config) {
    throw new Error("HTTPDataProvider must be initialized with config on first call");
  }
  if (config && !httpDataProvider) {
    httpDataProvider = new HTTPDataProvider(config);
  } else if (config && httpDataProvider) {
    httpDataProvider.updateConfig(config);
  }
  return httpDataProvider;
}
function destroyHTTPDataProvider() {
  httpDataProvider = null;
}

// src/services/ChartDataCoordinator.ts
var isBrowser = () => {
  if (typeof window === "undefined") return false;
  try {
    return window.__TAURI__ === void 0 && window.__TAURI_INTERNALS__ === void 0 && window.__TAURI_IPC__ === void 0 && window.location.protocol !== "tauri:";
  } catch {
    return false;
  }
};
var ChartDataCoordinator = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.defaultRanges = /* @__PURE__ */ new Map();
    this.metadataCache = /* @__PURE__ */ new Map();
    this.cacheTimeout = 10 * 60 * 1e3;
    // 10 minutes
    this.logger = createLogger("ChartDataCoordinator");
    this.useHTTP = isBrowser();
    // Auto-detect: true in browser, false in Tauri
    // Request tracking for debugging duplicate requests
    this.requestStats = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      pendingReuse: 0,
      backendCalls: 0
    };
    // Normalization factors must match backend
    this.normalizationFactors = {
      "5m": 900,
      // 15 minutes
      "15m": 3600,
      // 1 hour
      "1h": 7200,
      // 2 hours
      "4h": 14400,
      // 4 hours
      "12h": 43200
      // 12 hours
    };
  }
  /**
   * Get or set the default range for a symbol-timeframe combination
   */
  setDefaultRange(symbol, timeframe, from, to) {
    const key = `${symbol}-${timeframe}`;
    this.defaultRanges.set(key, { from, to });
    this.logger.debug(`Set default range for ${key}: ${from} - ${to}`);
  }
  /**
   * Generate cache key matching backend logic
   */
  getCacheKey(symbol, timeframe, from, to) {
    const factor = this.normalizationFactors[timeframe] || 3600;
    const normalizedFrom = Math.floor(from / factor) * factor;
    const normalizedTo = Math.floor(to / factor) * factor;
    return `${symbol}-${timeframe}-${normalizedFrom}-${normalizedTo}`;
  }
  /**
   * Check if cached data is still valid
   */
  isCacheValid(cached) {
    const age = Date.now() - cached.timestamp;
    return age < this.cacheTimeout;
  }
  /**
   * Calculate default range based on timeframe and available data
   * Uses FULL data range for ALL timeframes to ensure smooth transitions
   */
  async calculateDefaultRange(symbol, timeframe) {
    const metadata = await this.getSymbolMetadata(symbol);
    const dataEndTime = metadata?.data_to || Math.floor(Date.now() / 1e3);
    const dataStartTime = metadata?.data_from || dataEndTime - 365 * 24 * 60 * 60;
    this.logger.debug(
      `Calculated default range for ${symbol} ${timeframe}: ${new Date(dataStartTime * 1e3).toISOString()} to ${new Date(dataEndTime * 1e3).toISOString()}`
    );
    return { from: dataStartTime, to: dataEndTime };
  }
  /**
   * Main method to fetch chart data with coordination
   */
  async fetchChartData(symbol, timeframe, options) {
    if (!symbol || symbol.trim() === "") {
      this.logger.warn("Cannot fetch data for empty symbol");
      return [];
    }
    let range;
    if (options?.range) {
      range = options.range;
    } else {
      const defaultKey = `${symbol}-${timeframe}`;
      const storedRange = this.defaultRanges.get(defaultKey);
      if (storedRange) {
        range = storedRange;
      } else {
        range = await this.calculateDefaultRange(symbol, timeframe);
        this.setDefaultRange(symbol, timeframe, range.from, range.to);
      }
    }
    this.requestStats.totalRequests++;
    const cacheKey = this.getCacheKey(symbol, timeframe, range.from, range.to);
    this.logger.debug(`[REQUEST #${this.requestStats.totalRequests}] ${symbol}-${timeframe} \u2192 cache key: ${cacheKey}`);
    this.logger.debug(`  Raw range: ${range.from} - ${range.to}`);
    this.logger.debug(`  Normalized: ${this.getCacheKey(symbol, timeframe, range.from, range.to)}`);
    if (this.pendingRequests.has(cacheKey)) {
      this.requestStats.pendingReuse++;
      this.logger.info(`[PENDING REUSE] Reusing pending request for ${cacheKey} (${this.requestStats.pendingReuse} total reuses)`);
      return this.pendingRequests.get(cacheKey);
    }
    if (!options?.forceRefresh) {
      const cached = this.cache.get(cacheKey);
      if (cached && this.isCacheValid(cached)) {
        this.requestStats.cacheHits++;
        this.logger.info(`[CACHE HIT] ${cacheKey} (${cached.data.length} candles, ${this.requestStats.cacheHits} total hits)`);
        return cached.data;
      }
    }
    this.requestStats.cacheMisses++;
    this.requestStats.backendCalls++;
    this.logger.warn(`[CACHE MISS] ${cacheKey} \u2192 Backend call #${this.requestStats.backendCalls}`);
    const requestPromise = this.doFetch(symbol, timeframe, range.from, range.to).then((result) => {
      this.cache.set(cacheKey, {
        data: result.data,
        metadata: result.metadata,
        timestamp: Date.now(),
        range
      });
      this.pendingRequests.delete(cacheKey);
      this.logger.info(`Fetched and cached ${result.data.length} candles for ${cacheKey}`);
      return result.data;
    }).catch((error) => {
      this.pendingRequests.delete(cacheKey);
      throw error;
    });
    this.pendingRequests.set(cacheKey, requestPromise);
    return requestPromise;
  }
  /**
   * Enable HTTP data provider
   */
  enableHTTP(enable = true) {
    this.useHTTP = enable;
    this.logger.info(`HTTP data provider ${enable ? "enabled" : "disabled"}`);
  }
  /**
   * Perform the actual backend fetch
   */
  async doFetch(symbol, timeframe, from, to) {
    try {
      let response;
      if (this.useHTTP) {
        try {
          const httpProvider = getHTTPDataProvider();
          const candles = await httpProvider.fetchCandles({
            symbol,
            timeframe,
            from,
            to
          });
          response = candles;
        } catch (providerError) {
          this.logger.error(
            'HTTPDataProvider not initialized. Initialize it before using charts:\nimport { getHTTPDataProvider } from "sptrader-chart-lib";\ngetHTTPDataProvider({ baseUrl: "http://localhost:8080" });'
          );
          throw providerError;
        }
      } else {
        response = await invoke2("fetch_candles", {
          request: {
            symbol,
            timeframe,
            from,
            to
          }
        });
      }
      if (!response || !Array.isArray(response)) {
        this.logger.error("Invalid response format:", response);
        return { data: [], metadata: null };
      }
      const data = response.map((candle) => ({
        time: candle.time,
        // Already Unix timestamp from backend
        open: candle.open,
        high: candle.high,
        low: candle.low,
        close: candle.close
      }));
      const metadata = null;
      return { data, metadata };
    } catch (error) {
      this.logger.error("Fetch error:", error);
      throw error;
    }
  }
  /**
   * Get metadata for a symbol
   */
  async getSymbolMetadata(symbol) {
    if (!symbol || symbol.trim() === "") {
      this.logger.warn("Skipping metadata fetch for empty symbol");
      return null;
    }
    const cachedMeta = this.metadataCache.get(symbol);
    if (cachedMeta) {
      const age = Date.now() - cachedMeta.timestamp;
      if (age < this.cacheTimeout) {
        this.logger.debug(`Using cached metadata for ${symbol}`);
        return cachedMeta.metadata;
      }
    }
    for (const [key, cached] of this.cache.entries()) {
      if (key.startsWith(`${symbol}-`) && this.isCacheValid(cached) && cached.metadata) {
        this.logger.trace("Using metadata from candles cache for", symbol);
        return cached.metadata;
      }
    }
    try {
      let metadata;
      if (this.useHTTP) {
        try {
          const httpProvider = getHTTPDataProvider();
          const httpMetadata = await httpProvider.fetchMetadata(symbol);
          metadata = {
            data_from: httpMetadata.earliest,
            data_to: httpMetadata.latest
          };
        } catch (providerError) {
          this.logger.error(
            'HTTPDataProvider not initialized. Initialize it before using charts:\nimport { getHTTPDataProvider, chartDataCoordinator } from "sptrader-chart-lib";\ngetHTTPDataProvider({ baseUrl: "http://localhost:8080" });\nchartDataCoordinator.enableHTTP(true); // Optional if auto-detected'
          );
          throw providerError;
        }
      } else {
        metadata = await invoke2("get_symbol_metadata", { symbol });
      }
      this.metadataCache.set(symbol, {
        metadata,
        timestamp: Date.now()
      });
      return metadata;
    } catch (error) {
      this.logger.error("Failed to get metadata:", error);
      return null;
    }
  }
  /**
   * Invalidate cache entries
   */
  invalidateCache(pattern) {
    if (!pattern) {
      this.logger.info("Clearing entire cache");
      this.cache.clear();
      this.metadataCache.clear();
      this.defaultRanges.clear();
      return;
    }
    let removed = 0;
    let metadataRemoved = 0;
    for (const [key] of this.cache) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
        removed++;
      }
    }
    for (const [symbol] of this.metadataCache) {
      if (symbol.includes(pattern)) {
        this.metadataCache.delete(symbol);
        metadataRemoved++;
      }
    }
    for (const [key] of this.defaultRanges) {
      if (key.includes(pattern)) {
        this.defaultRanges.delete(key);
      }
    }
    this.logger.info(`Invalidated ${removed} cache entries and ${metadataRemoved} metadata entries matching: ${pattern}`);
  }
  /**
   * Cancel all pending requests
   */
  cancelPendingRequests() {
    this.logger.info(`Cancelling ${this.pendingRequests.size} pending requests`);
    this.pendingRequests.clear();
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      cacheSize: this.cache.size,
      pendingRequests: this.pendingRequests.size,
      defaultRanges: this.defaultRanges.size,
      requestStats: this.requestStats
    };
  }
  /**
   * Get request statistics for debugging
   */
  getRequestStats() {
    const hitRate = this.requestStats.totalRequests > 0 ? (this.requestStats.cacheHits / this.requestStats.totalRequests * 100).toFixed(1) : "0";
    return {
      ...this.requestStats,
      cacheHitRate: `${hitRate}%`,
      duplicatesAvoided: this.requestStats.pendingReuse
    };
  }
  /**
   * Reset request statistics
   */
  resetRequestStats() {
    this.requestStats = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      pendingReuse: 0,
      backendCalls: 0
    };
    this.logger.info("Request statistics reset");
  }
};
var chartDataCoordinator = new ChartDataCoordinator();

// src/primitives/CountdownTimerPrimitive.ts
var logger5 = createLogger("CountdownTimerPrimitive");
var CountdownTimerPaneView = class {
  constructor(primitive) {
    this._primitive = primitive;
  }
  zOrder() {
    return "top";
  }
  renderer() {
    return {
      draw: (target) => {
        const ctx = target._context;
        if (!ctx) {
          return;
        }
        const { countdown, color, position, offset } = this._primitive.getData();
        ctx.save();
        ctx.font = "12px monospace";
        ctx.textBaseline = "top";
        const countdownWidth = ctx.measureText(countdown).width;
        const totalWidth = countdownWidth + 16;
        const height = 24;
        const canvasWidth = target._mediaSize.width;
        const canvasHeight = target._mediaSize.height;
        let x = 0;
        let y = 0;
        switch (position) {
          case "top-left":
            x = offset.x;
            y = offset.y;
            break;
          case "top-right":
            x = canvasWidth - totalWidth - offset.x;
            y = offset.y;
            break;
          case "bottom-left":
            x = offset.x;
            y = canvasHeight - height - offset.y;
            break;
          case "bottom-right":
            x = canvasWidth - totalWidth - offset.x;
            y = canvasHeight - height - offset.y;
            break;
        }
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(x, y, totalWidth, height);
        ctx.fillStyle = color;
        ctx.font = "12px monospace";
        ctx.fillText(countdown, x + 8, y + 6);
        ctx.restore();
      }
    };
  }
};
var CountdownTimerPrimitive = class {
  constructor(options) {
    this._countdown = "00:00";
    this._color = "#999";
    this._intervalId = null;
    this._requestUpdate = null;
    this._hasTriggered = false;
    this._timeframe = options.timeframe;
    this._position = options.position || "bottom-right";
    this._offset = options.offset || { x: 10, y: 10 };
    this._onNewCandleBoundary = options.onNewCandleBoundary;
    this._paneViews = [new CountdownTimerPaneView(this)];
  }
  updateTimeframe(timeframe) {
    this._timeframe = timeframe;
    this._requestUpdate?.();
  }
  attached(param) {
    this._requestUpdate = param.requestUpdate;
    this._startCountdown();
  }
  detached() {
    this._stopCountdown();
  }
  paneViews() {
    return this._paneViews;
  }
  updateAllViews() {
  }
  _startCountdown() {
    this._updateCountdown();
    this._intervalId = window.setInterval(() => {
      this._updateCountdown();
    }, 1e3);
  }
  _stopCountdown() {
    if (this._intervalId !== null) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }
  _calculateSecondsToNextCandle() {
    const now = /* @__PURE__ */ new Date();
    const seconds = now.getUTCSeconds();
    const minutes = now.getUTCMinutes();
    const hours = now.getUTCHours();
    switch (this._timeframe) {
      case "5m":
        return (5 - minutes % 5) * 60 - seconds;
      case "15m":
        return (15 - minutes % 15) * 60 - seconds;
      case "1h":
        return (60 - minutes) * 60 - seconds;
      case "4h":
        return (4 - hours % 4) * 3600 + (60 - minutes) * 60 - seconds;
      case "12h":
        return (12 - hours % 12) * 3600 + (60 - minutes) * 60 - seconds;
      default:
        return (60 - minutes) * 60 - seconds;
    }
  }
  _formatCountdown(totalSeconds) {
    const displaySeconds = Math.max(0, totalSeconds);
    const minutes = Math.floor(displaySeconds / 60);
    const seconds = displaySeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  _getCountdownColor(seconds) {
    if (seconds <= 10) {
      return "#ffae00";
    } else if (seconds <= 30) {
      return "#ccc";
    } else {
      return "#999";
    }
  }
  _updateCountdown() {
    const totalSeconds = this._calculateSecondsToNextCandle();
    this._countdown = this._formatCountdown(totalSeconds);
    this._color = this._getCountdownColor(totalSeconds);
    if (totalSeconds <= 0 && !this._hasTriggered) {
      this._hasTriggered = true;
      const candleTime = Math.floor(Date.now() / 1e3);
      this._onNewCandleBoundary?.(candleTime);
      logger5.debug("New candle boundary:", candleTime);
    }
    if (totalSeconds > 5) {
      this._hasTriggered = false;
    }
    this._requestUpdate?.();
  }
  getData() {
    return {
      countdown: this._countdown,
      color: this._color,
      position: this._position,
      offset: this._offset
    };
  }
};

// src/primitives/TimeframeWatermarkPrimitive.ts
var WatermarkPaneView = class {
  constructor(primitive) {
    this._primitive = primitive;
  }
  zOrder() {
    return "bottom";
  }
  renderer() {
    return {
      draw: (target) => {
        const ctx = target._context;
        if (!ctx) {
          return;
        }
        const { timeframe, opacity, fontSize } = this._primitive.getData();
        ctx.save();
        const canvasWidth = target._mediaSize.width;
        const canvasHeight = target._mediaSize.height;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;
        ctx.font = `700 ${fontSize}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.letterSpacing = "0.1em";
        ctx.fillText(timeframe.toUpperCase(), centerX, centerY);
        ctx.restore();
      }
    };
  }
};
var TimeframeWatermarkPrimitive = class {
  constructor(options) {
    this._requestUpdate = null;
    this._timeframe = options.timeframe;
    this._opacity = options.opacity || 0.2;
    this._fontSize = options.fontSize || 72;
    this._paneViews = [new WatermarkPaneView(this)];
  }
  updateTimeframe(timeframe) {
    this._timeframe = timeframe;
    this._requestUpdate?.();
  }
  attached(param) {
    this._requestUpdate = param.requestUpdate;
  }
  detached() {
  }
  paneViews() {
    return this._paneViews;
  }
  updateAllViews() {
  }
  getData() {
    return {
      timeframe: this._timeframe,
      opacity: this._opacity,
      fontSize: this._fontSize
    };
  }
};

// src/constants/timeframes.ts
var TIMEFRAME_SECONDS = {
  "5m": 5 * 60,
  // 300
  "15m": 15 * 60,
  // 900
  "1h": 60 * 60,
  // 3600
  "4h": 4 * 60 * 60,
  // 14400
  "12h": 12 * 60 * 60
  // 43200
};
var ALL_TIMEFRAMES = ["5m", "15m", "1h", "4h", "12h"];
var DEFAULT_TIMEFRAME = "1h";
function getTimeframePeriodSeconds(timeframe) {
  return TIMEFRAME_SECONDS[timeframe] || TIMEFRAME_SECONDS[DEFAULT_TIMEFRAME];
}
var TIMEFRAME_SWITCH_THRESHOLDS = {
  "5m": {
    zoomOut: 5,
    // Switch to 15m when bar spacing < 5 (wider gap prevents thrashing)
    zoomIn: 40
    // Switch from 15m when bar spacing > 40 (wider gap prevents thrashing)
  },
  "15m": {
    zoomOut: 5,
    // Switch to 1h when bar spacing < 5 (wider gap prevents thrashing)
    zoomIn: 40
    // Switch from 1h when bar spacing > 40 (wider gap prevents thrashing)
  },
  "1h": {
    zoomOut: 5,
    // Switch to 4h when bar spacing < 5 (wider gap prevents thrashing)
    zoomIn: 40
    // Switch from 4h when bar spacing > 40 (wider gap prevents thrashing)
  },
  "4h": {
    zoomOut: 3,
    // Switch to 12h when bar spacing < 3
    zoomIn: 40
    // Switch from 1h when bar spacing > 40 (wider gap prevents thrashing)
  },
  "12h": {
    zoomOut: 3,
    // Can't zoom out further
    zoomIn: 30
    // Switch from 4h when bar spacing > 30 (wider gap prevents thrashing)
  }
};
var ADJACENT_TIMEFRAMES = {
  "5m": ["15m"],
  // Can only zoom out to 15m
  "15m": ["5m", "1h"],
  // Can zoom in to 5m or out to 1h
  "1h": ["15m", "4h"],
  // Can zoom in to 15m or out to 4h
  "4h": ["1h", "12h"],
  // Can zoom in to 1h or out to 12h
  "12h": ["4h"]
  // Can only zoom in to 4h
};

// src/hooks/usePlaceholderCandle.ts
var logger6 = createLogger("usePlaceholderCandle");
function usePlaceholderCandle(series, options) {
  const { onPlaceholderCreated, resetDelay = 5e3 } = options || {};
  const hasTriggeredRef = React3.useRef(false);
  const placeholderTimeRef = React3.useRef(null);
  const resetTimeoutRef = React3.useRef(null);
  const createPlaceholder = React3.useCallback((candleTime) => {
    if (!series || hasTriggeredRef.current) {
      logger6.trace("Skipping - no series or already triggered");
      return;
    }
    logger6.debug(`Creating placeholder at ${new Date(candleTime * 1e3).toISOString()}`);
    hasTriggeredRef.current = true;
    const currentData = series.data();
    if (currentData.length === 0) {
      logger6.debug("No data to create placeholder from");
      return;
    }
    const lastCandle = currentData[currentData.length - 1];
    if (!lastCandle || !("close" in lastCandle)) {
      logger6.debug("Last data point is not a valid candle");
      return;
    }
    const placeholderCandle = {
      time: candleTime,
      open: lastCandle.close,
      high: lastCandle.close,
      low: lastCandle.close,
      close: lastCandle.close
    };
    const newData = [...currentData, placeholderCandle];
    series.setData(newData);
    logger6.debug(
      "Placeholder created at",
      new Date(candleTime * 1e3).toLocaleTimeString()
    );
    placeholderTimeRef.current = candleTime;
    onPlaceholderCreated?.(candleTime);
    if (resetTimeoutRef.current) {
      clearTimeout(resetTimeoutRef.current);
    }
    resetTimeoutRef.current = setTimeout(() => {
      logger6.trace("Resetting trigger");
      hasTriggeredRef.current = false;
      if (placeholderTimeRef.current === -1) {
        placeholderTimeRef.current = null;
      }
    }, resetDelay);
  }, [series, onPlaceholderCreated, resetDelay]);
  const updateWithRealData = React3.useCallback((data) => {
    if (!placeholderTimeRef.current || !series) {
      return;
    }
    const placeholderTime = placeholderTimeRef.current;
    const hasRealData = data.some(
      (candle) => candle.time === placeholderTime
    );
    if (hasRealData) {
      logger6.debug(
        "Replacing placeholder with real data at",
        new Date(placeholderTime * 1e3).toLocaleTimeString()
      );
      placeholderTimeRef.current = null;
      series.setData(data);
    }
  }, [series]);
  const hasPlaceholder = React3.useCallback(() => {
    return placeholderTimeRef.current !== null;
  }, []);
  const getPlaceholderTime = React3.useCallback(() => {
    return placeholderTimeRef.current;
  }, []);
  const resetTrigger = React3.useCallback(() => {
    hasTriggeredRef.current = false;
    placeholderTimeRef.current = null;
    if (resetTimeoutRef.current) {
      clearTimeout(resetTimeoutRef.current);
      resetTimeoutRef.current = null;
    }
  }, []);
  return {
    createPlaceholder,
    updateWithRealData,
    hasPlaceholder,
    getPlaceholderTime,
    resetTrigger
  };
}
function calculateCandleTime(timestamp, timeframe) {
  const period = TIMEFRAME_SECONDS[timeframe] || TIMEFRAME_SECONDS["1h"];
  return Math.floor(timestamp / period) * period;
}

// src/utils/chartHelpers.ts
function calculateBarSpacingForTimeframeSwitch(currentBarSpacing, fromTimeframe, toTimeframe) {
  const transitions = {
    "5m->15m": 3,
    "15m->5m": 1 / 3,
    "15m->1h": 4,
    "1h->15m": 1 / 4,
    "1h->4h": 4,
    "4h->1h": 1 / 4,
    "4h->12h": 3,
    "12h->4h": 1 / 3
  };
  const key = `${fromTimeframe}->${toTimeframe}`;
  const multiplier = transitions[key] || 1;
  const newBarSpacing = currentBarSpacing * multiplier;
  return Math.max(3, Math.min(50, newBarSpacing));
}
function getDaysToShowForTimeframe(timeframe) {
  switch (timeframe) {
    case "5m":
      return 2;
    case "15m":
      return 3;
    case "1h":
      return 7;
    case "4h":
      return 14;
    case "12h":
      return 30;
    default:
      return 7;
  }
}
function setVisibleRangeByDays(chart, days) {
  const now = Math.floor(Date.now() / 1e3);
  const from = now - days * 24 * 60 * 60;
  chart.timeScale().setVisibleRange({
    from,
    to: now
  });
}
function getVisibleRangeDuration(chart) {
  const range = chart.timeScale().getVisibleRange();
  if (!range) return 0;
  return range.to - range.from;
}
function isTimeVisible(chart, time) {
  const range = chart.timeScale().getVisibleRange();
  if (!range) return false;
  return time >= range.from && time <= range.to;
}
function scrollToTime(chart, time, center = true) {
  if (center) {
    const range = chart.timeScale().getVisibleRange();
    if (range) {
      const duration = range.to - range.from;
      chart.timeScale().setVisibleRange({
        from: time - duration / 2,
        to: time + duration / 2
      });
    }
  } else {
    chart.timeScale().scrollToPosition(0, false);
    chart.timeScale().scrollToRealTime();
  }
}
function findLastRealCandle(series) {
  const data = series.data();
  if (data.length === 0) return null;
  for (let i = data.length - 1; i >= 0; i--) {
    const candle = data[i];
    if (!candle) continue;
    if ("open" in candle && "high" in candle && "low" in candle && "close" in candle) {
      if (candle.open !== candle.high || candle.open !== candle.low || candle.open !== candle.close) {
        return candle;
      }
    }
  }
  const lastCandle = data[data.length - 1];
  return lastCandle && "close" in lastCandle ? lastCandle : null;
}
function createPlaceholderCandle(lastCandle, timeframe, currentTime) {
  const periodSeconds = getTimeframePeriodSeconds(timeframe);
  const candleTime = Math.floor(currentTime / periodSeconds) * periodSeconds;
  const price = lastCandle?.close ?? lastCandle?.open ?? 0;
  return {
    time: candleTime,
    open: price,
    high: price,
    low: price,
    close: price
  };
}
var logger7 = createLogger("ErrorBoundary");
var ErrorBoundary = class extends React3.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = () => {
      logger7.info("Resetting error boundary");
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null
      });
    };
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error,
      errorInfo: null
    };
  }
  componentDidCatch(error, errorInfo) {
    logger7.error("Error caught by boundary:", error, errorInfo);
    this.setState({
      errorInfo
    });
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }
  componentDidUpdate(prevProps) {
    const { resetKeys, resetOnPropsChange } = this.props;
    const { hasError } = this.state;
    if (hasError && prevProps.resetKeys !== resetKeys) {
      if (resetKeys?.some((key, idx) => key !== prevProps.resetKeys?.[idx])) {
        this.resetErrorBoundary();
      }
    }
    if (hasError && resetOnPropsChange && prevProps.children !== this.props.children) {
      this.resetErrorBoundary();
    }
  }
  render() {
    const { hasError, error, errorInfo } = this.state;
    const { fallback, children } = this.props;
    if (hasError && error) {
      if (fallback) {
        return fallback(error, errorInfo, this.resetErrorBoundary);
      }
      return /* @__PURE__ */ jsxRuntime.jsxs(
        "div",
        {
          style: {
            padding: "20px",
            margin: "20px",
            border: "1px solid #ff6b6b",
            borderRadius: "8px",
            backgroundColor: "#ffe0e0",
            fontFamily: "system-ui, -apple-system, sans-serif"
          },
          children: [
            /* @__PURE__ */ jsxRuntime.jsx("h2", { style: { color: "#c92a2a", marginTop: 0 }, children: "Something went wrong" }),
            /* @__PURE__ */ jsxRuntime.jsxs("details", { style: { whiteSpace: "pre-wrap", marginBottom: "20px" }, children: [
              /* @__PURE__ */ jsxRuntime.jsx("summary", { style: { cursor: "pointer", color: "#666" }, children: "Error details" }),
              /* @__PURE__ */ jsxRuntime.jsx("p", { style: { color: "#666", marginTop: "10px" }, children: error.toString() }),
              errorInfo && /* @__PURE__ */ jsxRuntime.jsx("pre", { style: { color: "#666", fontSize: "12px", overflow: "auto" }, children: errorInfo.componentStack })
            ] }),
            /* @__PURE__ */ jsxRuntime.jsx(
              "button",
              {
                onClick: this.resetErrorBoundary,
                style: {
                  padding: "8px 16px",
                  fontSize: "14px",
                  color: "#fff",
                  backgroundColor: "#c92a2a",
                  border: "none",
                  borderRadius: "4px",
                  cursor: "pointer"
                },
                children: "Try Again"
              }
            )
          ]
        }
      );
    }
    return children;
  }
};
var ChartErrorBoundary = ({
  children,
  onError
}) => {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ErrorBoundary,
    {
      onError,
      fallback: (error, _errorInfo, retry) => /* @__PURE__ */ jsxRuntime.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            minHeight: "400px",
            padding: "40px",
            backgroundColor: "#f8f9fa",
            borderRadius: "8px",
            textAlign: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              "div",
              {
                style: {
                  fontSize: "48px",
                  marginBottom: "20px",
                  color: "#dee2e6"
                },
                children: "\u{1F4CA}"
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              "h3",
              {
                style: {
                  margin: "0 0 10px 0",
                  fontSize: "20px",
                  fontWeight: "600",
                  color: "#495057"
                },
                children: "Chart Error"
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              "p",
              {
                style: {
                  margin: "0 0 20px 0",
                  fontSize: "14px",
                  color: "#6c757d",
                  maxWidth: "400px"
                },
                children: error.message || "An unexpected error occurred while rendering the chart."
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { display: "flex", gap: "10px" }, children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                "button",
                {
                  onClick: retry,
                  style: {
                    padding: "10px 20px",
                    fontSize: "14px",
                    fontWeight: "500",
                    color: "#fff",
                    backgroundColor: "#007bff",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer",
                    transition: "background-color 0.2s"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#0056b3";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#007bff";
                  },
                  children: "Reload Chart"
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(
                "button",
                {
                  onClick: () => window.location.reload(),
                  style: {
                    padding: "10px 20px",
                    fontSize: "14px",
                    fontWeight: "500",
                    color: "#495057",
                    backgroundColor: "#fff",
                    border: "1px solid #dee2e6",
                    borderRadius: "4px",
                    cursor: "pointer",
                    transition: "all 0.2s"
                  },
                  onMouseEnter: (e) => {
                    e.currentTarget.style.backgroundColor = "#f8f9fa";
                    e.currentTarget.style.borderColor = "#adb5bd";
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = "#fff";
                    e.currentTarget.style.borderColor = "#dee2e6";
                  },
                  children: "Refresh Page"
                }
              )
            ] }),
            process.env.NODE_ENV === "development" && /* @__PURE__ */ jsxRuntime.jsxs(
              "details",
              {
                style: {
                  marginTop: "30px",
                  padding: "15px",
                  backgroundColor: "#fff",
                  border: "1px solid #dee2e6",
                  borderRadius: "4px",
                  textAlign: "left",
                  maxWidth: "600px",
                  width: "100%"
                },
                children: [
                  /* @__PURE__ */ jsxRuntime.jsx(
                    "summary",
                    {
                      style: {
                        cursor: "pointer",
                        fontWeight: "500",
                        color: "#495057",
                        marginBottom: "10px"
                      },
                      children: "Technical Details"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    "pre",
                    {
                      style: {
                        margin: 0,
                        fontSize: "12px",
                        color: "#6c757d",
                        whiteSpace: "pre-wrap",
                        wordBreak: "break-word"
                      },
                      children: error.stack
                    }
                  )
                ]
              }
            )
          ]
        }
      ),
      children
    }
  );
};
var LoadingState = ({
  message = "Loading...",
  subMessage,
  showSpinner = true,
  height = "100%",
  overlay = false
}) => {
  const content = /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: typeof height === "number" ? `${height}px` : height,
        minHeight: overlay ? "auto" : "200px",
        padding: "40px",
        backgroundColor: overlay ? "rgba(255, 255, 255, 0.9)" : "transparent",
        position: overlay ? "absolute" : "relative",
        inset: overlay ? 0 : "auto",
        zIndex: overlay ? 1e3 : "auto"
      },
      children: [
        showSpinner && /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              width: "40px",
              height: "40px",
              marginBottom: "20px",
              border: "3px solid #e9ecef",
              borderTopColor: "#007bff",
              borderRadius: "50%",
              animation: "spin 1s linear infinite"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              fontSize: "16px",
              fontWeight: "500",
              color: "#495057",
              marginBottom: subMessage ? "8px" : 0
            },
            children: message
          }
        ),
        subMessage && /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              fontSize: "14px",
              color: "#6c757d"
            },
            children: subMessage
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` })
      ]
    }
  );
  return content;
};
var ChartLoadingState = ({
  symbol,
  timeframe
}) => {
  return /* @__PURE__ */ jsxRuntime.jsx(
    LoadingState,
    {
      message: `Loading ${symbol ? `${symbol} ` : ""}chart data${timeframe ? ` (${timeframe})` : ""}...`,
      height: "400px"
    }
  );
};
var ChartSkeleton = ({ height = "400px" }) => {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      style: {
        position: "relative",
        width: "100%",
        height: typeof height === "number" ? `${height}px` : height,
        backgroundColor: "#f8f9fa",
        borderRadius: "8px",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              position: "absolute",
              right: 0,
              top: 0,
              bottom: 40,
              width: "60px",
              backgroundColor: "#e9ecef",
              animation: "shimmer 1.5s infinite"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 60,
              bottom: 0,
              height: "40px",
              backgroundColor: "#e9ecef",
              animation: "shimmer 1.5s infinite",
              animationDelay: "0.2s"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 60,
              top: 0,
              bottom: 40,
              padding: "20px"
            },
            children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { display: "flex", justifyContent: "space-around", height: "100%", alignItems: "flex-end" }, children: [...Array(8)].map((_, i) => /* @__PURE__ */ jsxRuntime.jsx(
              "div",
              {
                style: {
                  width: "8px",
                  height: `${Math.random() * 60 + 20}%`,
                  backgroundColor: "#dee2e6",
                  borderRadius: "2px",
                  animation: "shimmer 1.5s infinite",
                  animationDelay: `${i * 0.1}s`
                }
              },
              i
            )) })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("style", { children: `
          @keyframes shimmer {
            0% { opacity: 0.6; }
            50% { opacity: 0.8; }
            100% { opacity: 0.6; }
          }
        ` })
      ]
    }
  );
};
var InlineLoader = ({ text = "Updating..." }) => {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      style: {
        display: "inline-flex",
        alignItems: "center",
        gap: "8px",
        padding: "4px 12px",
        backgroundColor: "#e7f3ff",
        borderRadius: "4px",
        fontSize: "13px",
        color: "#0066cc"
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              width: "12px",
              height: "12px",
              border: "2px solid #cce5ff",
              borderTopColor: "#0066cc",
              borderRadius: "50%",
              animation: "spin 0.8s linear infinite"
            }
          }
        ),
        text,
        /* @__PURE__ */ jsxRuntime.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` })
      ]
    }
  );
};
var EmptyState = ({
  title = "No Data Available",
  message = "There is no data to display at this time.",
  icon,
  action,
  height = "100%"
}) => {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: typeof height === "number" ? `${height}px` : height,
        minHeight: "300px",
        padding: "40px",
        textAlign: "center"
      },
      children: [
        icon || /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              fontSize: "48px",
              marginBottom: "20px",
              color: "#dee2e6"
            },
            children: "\u{1F4CA}"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "h3",
          {
            style: {
              margin: "0 0 10px 0",
              fontSize: "20px",
              fontWeight: "600",
              color: "#495057"
            },
            children: title
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "p",
          {
            style: {
              margin: "0 0 20px 0",
              fontSize: "14px",
              color: "#6c757d",
              maxWidth: "400px"
            },
            children: message
          }
        ),
        action && /* @__PURE__ */ jsxRuntime.jsx(
          "button",
          {
            onClick: action.onClick,
            style: {
              padding: "10px 20px",
              fontSize: "14px",
              fontWeight: "500",
              color: "#fff",
              backgroundColor: "#007bff",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
              transition: "background-color 0.2s"
            },
            onMouseEnter: (e) => {
              e.currentTarget.style.backgroundColor = "#0056b3";
            },
            onMouseLeave: (e) => {
              e.currentTarget.style.backgroundColor = "#007bff";
            },
            children: action.label
          }
        )
      ]
    }
  );
};
var ChartEmptyState = ({ symbol, onSelectSymbol }) => {
  if (!symbol) {
    return /* @__PURE__ */ jsxRuntime.jsx(
      EmptyState,
      {
        title: "No Symbol Selected",
        message: "Please select a trading pair to view the chart.",
        icon: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { fontSize: "48px", marginBottom: "20px", color: "#dee2e6" }, children: "\u{1F50D}" }),
        action: onSelectSymbol ? {
          label: "Select Symbol",
          onClick: onSelectSymbol
        } : void 0,
        height: "400px"
      }
    );
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    EmptyState,
    {
      title: "No Chart Data",
      message: `Unable to load chart data for ${symbol}. Please try again later.`,
      height: "400px"
    }
  );
};
var NoDataInRangeState = ({ timeframe, onChangeTimeframe }) => {
  return /* @__PURE__ */ jsxRuntime.jsx(
    EmptyState,
    {
      title: "No Data in This Range",
      message: `There is no data available for the ${timeframe} timeframe in the current range.`,
      icon: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { fontSize: "48px", marginBottom: "20px", color: "#dee2e6" }, children: "\u{1F4C5}" }),
      action: onChangeTimeframe ? {
        label: "Change Timeframe",
        onClick: onChangeTimeframe
      } : void 0,
      height: "400px"
    }
  );
};
var logger8 = createLogger("MarketDataChart");
var MarketDataChart = ({
  symbol,
  timeframe,
  onTimeframeChange,
  enableTimeframeAutoSwitch = true,
  preloadAdjacentTimeframes = true
}) => {
  const chartContainerRef = React3.useRef(null);
  const chartRef = React3.useRef(null);
  const seriesRef = React3.useRef(null);
  const countdownTimerRef = React3.useRef(null);
  const watermarkRef = React3.useRef(null);
  const [currentTimeframe, setCurrentTimeframe] = React3.useState(timeframe || "1h");
  const currentTimeframeRef = React3.useRef(timeframe || "1h");
  const symbolRef = React3.useRef(symbol || "EURUSD");
  const [isLoading, setIsLoading] = React3.useState(false);
  const [_error, setError] = React3.useState(null);
  const isTransitioningRef = React3.useRef(false);
  const {
    setCurrentTimeframe: setStoreTimeframe
  } = useChartStore();
  const {
    createPlaceholder,
    updateWithRealData,
    hasPlaceholder,
    resetTrigger
  } = usePlaceholderCandle(seriesRef.current);
  const lastTransitionRef = React3.useRef(0);
  const TRANSITION_COOLDOWN = 700;
  const [isShiftPressed, setIsShiftPressed] = React3.useState(false);
  const lockedLeftEdgeRef = React3.useRef(null);
  const checkIntervalRef = React3.useRef(null);
  const initialLoadDoneRef = React3.useRef(false);
  const formatPrice = (price) => {
    if (price >= 1e3) {
      return `$${price.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    } else if (price >= 100) {
      return `$${price.toFixed(2)}`;
    } else {
      return `$${price.toFixed(5)}`;
    }
  };
  const fetchChartData = async (sym, tf, from, to) => {
    try {
      const data = await chartDataCoordinator.fetchChartData(sym, tf, {
        range: from && to ? { from, to } : void 0
      });
      const metadata = await chartDataCoordinator.getSymbolMetadata(sym);
      return {
        data,
        metadata
      };
    } catch (error) {
      logger8.error(`Error fetching market chart data for ${sym} ${tf}:`, error);
      return { data: [], metadata: null };
    }
  };
  const switchTimeframe = async (newTimeframe) => {
    if (newTimeframe === currentTimeframeRef.current || isTransitioningRef.current) return;
    logger8.debug(
      "Timeframe transition:",
      currentTimeframeRef.current,
      "\u2192",
      newTimeframe
    );
    const now = Date.now();
    if (now - lastTransitionRef.current < TRANSITION_COOLDOWN) {
      logger8.debug("[COOLDOWN] Too fast! Wait a bit...");
      return;
    }
    lastTransitionRef.current = now;
    isTransitioningRef.current = true;
    const timeScale = chartRef.current.timeScale();
    const currentBarSpacing = timeScale.options().barSpacing;
    const visibleRange = timeScale.getVisibleRange();
    const previousTimeframe = currentTimeframeRef.current;
    logger8.info(
      `Executing transition: ${previousTimeframe} \u2192 ${newTimeframe} at bar spacing ${currentBarSpacing}`
    );
    currentTimeframeRef.current = newTimeframe;
    setCurrentTimeframe(newTimeframe);
    setStoreTimeframe(newTimeframe);
    if (onTimeframeChange) {
      onTimeframeChange(newTimeframe);
    }
    watermarkRef.current?.updateTimeframe(newTimeframe);
    countdownTimerRef.current?.updateTimeframe(newTimeframe);
    try {
      logger8.debug(`Fetching ${newTimeframe} data using cached/default range`);
      const { data } = await fetchChartData(symbolRef.current, newTimeframe);
      logger8.debug(`Fetch completed, got ${data.length} candles`);
      if (data.length === 0) {
        logger8.error(`No data available for ${newTimeframe} - aborting transition`);
        currentTimeframeRef.current = previousTimeframe;
        setCurrentTimeframe(previousTimeframe);
        setStoreTimeframe(previousTimeframe);
        isTransitioningRef.current = false;
        return;
      }
      if (data.length > 0 && seriesRef.current && chartRef.current) {
        logger8.debug(`Setting ${data.length} candles on series`);
        seriesRef.current.setData(data.map((d) => ({ ...d, time: d.time })));
        logger8.debug(`Data set complete`);
        if (visibleRange && chartRef.current) {
          const dataStart = data[0].time;
          const dataEnd = data[data.length - 1].time;
          const clampedFrom = Math.max(visibleRange.from, dataStart);
          const clampedTo = Math.min(visibleRange.to, dataEnd);
          logger8.debug(`Data range: ${new Date(dataStart * 1e3).toISOString()} to ${new Date(dataEnd * 1e3).toISOString()}`);
          logger8.debug(`Visible range: ${new Date(visibleRange.from * 1e3).toISOString()} to ${new Date(visibleRange.to * 1e3).toISOString()}`);
          logger8.debug(`Clamped range: ${new Date(clampedFrom * 1e3).toISOString()} to ${new Date(clampedTo * 1e3).toISOString()}`);
          if (clampedFrom < clampedTo) {
            chartRef.current.timeScale().setVisibleRange({
              from: clampedFrom,
              to: clampedTo
            });
          } else {
            logger8.warn(`Visible range outside data bounds, showing end of data`);
            const daysToShow = getDaysToShowForTimeframe(newTimeframe);
            const from = dataEnd - daysToShow * 24 * 60 * 60;
            chartRef.current.timeScale().setVisibleRange({
              from: Math.max(from, dataStart),
              to: dataEnd
            });
          }
        }
      }
      logger8.info(`Transition complete to ${newTimeframe}`);
    } catch (error) {
      logger8.error("Failed to switch timeframe:", error);
      currentTimeframeRef.current = previousTimeframe;
      setCurrentTimeframe(previousTimeframe);
      setStoreTimeframe(previousTimeframe);
    } finally {
      logger8.debug(`Setting isTransitioningRef to false`);
      isTransitioningRef.current = false;
    }
  };
  React3.useEffect(() => {
    if (!chartContainerRef.current) return;
    logger8.info("Creating chart");
    let crosshairUnsubscribe;
    const chart = lightweightCharts.createChart(chartContainerRef.current, {
      autoSize: true,
      // Automatically size the chart to fit container
      layout: {
        background: { color: "#16161d" },
        textColor: "#d0d0d2"
      },
      grid: {
        vertLines: { color: "#1a2a3a" },
        horzLines: { color: "#1a2a3a" }
      },
      crosshair: {
        mode: 0,
        // Normal mode - shows both crosshair lines
        vertLine: {
          color: "#758696",
          width: 1,
          style: 3,
          // Dashed
          labelBackgroundColor: "#2B2B43"
        },
        horzLine: {
          color: "#758696",
          width: 1,
          style: 3,
          // Dashed
          labelBackgroundColor: "#2B2B43"
        }
      },
      timeScale: {
        visible: true,
        // Show the time axis
        timeVisible: true,
        secondsVisible: false,
        barSpacing: 12,
        // Default bar spacing
        minBarSpacing: 2,
        // Prevent excessive zoom out
        rightOffset: 0,
        // Set to 0 to work with fixRightEdge
        rightBarStaysOnScroll: true,
        // Keep the latest bar in view when scrolling
        fixLeftEdge: true,
        // Prevent panning before first candle
        fixRightEdge: true,
        // Prevent panning after last candle
        tickMarkFormatter: (time, tickMarkType) => {
          const date = new Date(time * 1e3);
          if (tickMarkType === 0) {
            return date.getUTCFullYear().toString();
          } else if (tickMarkType === 1) {
            const months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            return months[date.getUTCMonth()];
          } else if (tickMarkType === 2) {
            const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
            const dayName = days[date.getUTCDay()];
            return `${dayName} ${date.getUTCDate()}`;
          } else if (tickMarkType === 3) {
            const hours = date.getUTCHours();
            const minutes = date.getUTCMinutes().toString().padStart(2, "0");
            return `${hours.toString().padStart(2, "0")}:${minutes}`;
          } else if (tickMarkType === 4) {
            const hours = date.getUTCHours();
            const minutes = date.getUTCMinutes().toString().padStart(2, "0");
            const seconds = date.getUTCSeconds().toString().padStart(2, "0");
            return `${hours.toString().padStart(2, "0")}:${minutes}:${seconds}`;
          }
          return date.toISOString();
        }
      },
      localization: {
        timeFormatter: (timestamp) => {
          const date = new Date(timestamp * 1e3);
          const hours = date.getUTCHours();
          const minutes = date.getUTCMinutes().toString().padStart(2, "0");
          return `${hours.toString().padStart(2, "0")}:${minutes} UTC`;
        }
      }
    });
    const candlestickSeries = chart.addCandlestickSeries({
      upColor: "#00ff88",
      downColor: "#ff4976",
      borderVisible: false,
      wickUpColor: "#00ff88",
      wickDownColor: "#ff4976",
      priceFormat: {
        type: "custom",
        formatter: formatPrice
      }
    });
    chartRef.current = chart;
    seriesRef.current = candlestickSeries;
    watermarkRef.current = new TimeframeWatermarkPrimitive({
      timeframe: currentTimeframe,
      opacity: 0.2,
      fontSize: 76
    });
    candlestickSeries.attachPrimitive(watermarkRef.current);
    countdownTimerRef.current = new CountdownTimerPrimitive({
      timeframe: currentTimeframe,
      position: "bottom-right",
      offset: { x: 10, y: 10 },
      onNewCandleBoundary: (time) => {
        const candleTime = calculateCandleTime(time, currentTimeframe);
        createPlaceholder(candleTime);
      }
    });
    candlestickSeries.attachPrimitive(countdownTimerRef.current);
    const toolTip = document.createElement("div");
    toolTip.style.cssText = `
      position: absolute;
      display: none;
      padding: 8px;
      box-sizing: border-box;
      font-size: 12px;
      text-align: left;
      z-index: 1000;
      top: 12px;
      left: 12px;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    chartContainerRef.current.appendChild(toolTip);
    const unsubscribe = chart.subscribeCrosshairMove((param) => {
      if (!param.time || !param.seriesData.has(candlestickSeries)) {
        toolTip.style.display = "none";
        return;
      }
      const data = param.seriesData.get(candlestickSeries);
      const timestamp = typeof param.time === "string" ? parseInt(param.time) * 1e3 : param.time * 1e3;
      const date = new Date(timestamp);
      const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const dayOfWeek = days[date.getUTCDay()];
      const month = months[date.getUTCMonth()];
      const dayOfMonth = date.getUTCDate();
      toolTip.style.display = "block";
      toolTip.innerHTML = `
        <div style="color: #666; margin-bottom: 4px; font-size: 11px">${dayOfWeek} ${month} ${dayOfMonth}</div>
        <div style="color: #fff">O: ${formatPrice(data.open)}</div>
        <div style="color: #fff">H: ${formatPrice(data.high)}</div>
        <div style="color: #fff">L: ${formatPrice(data.low)}</div>
        <div style="color: ${data.close >= data.open ? "#00ff88" : "#ff4976"}">C: ${formatPrice(data.close)}</div>
      `;
    });
    if (typeof unsubscribe === "function") {
      crosshairUnsubscribe = unsubscribe;
    }
    let lastBarSpacing = 13;
    const checkTimeframeSwitch = (barSpacing) => {
      logger8.debug(`checkTimeframeSwitch called with barSpacing: ${barSpacing}`);
      logger8.debug(`isTransitioningRef.current: ${isTransitioningRef.current}`);
      logger8.debug(`currentTimeframeRef.current: ${currentTimeframeRef.current}`);
      if (!enableTimeframeAutoSwitch) {
        logger8.debug("[SWITCH] Auto-switching disabled");
        return;
      }
      if (isTransitioningRef.current) {
        logger8.debug("[SWITCH] Skipping - transition in progress");
        return;
      }
      const currentTf = currentTimeframeRef.current;
      if (currentTf === "12h" && barSpacing < 3) {
        logger8.debug("[ZOOM LIMIT] Enforcing minimum bar spacing for 12h");
        chartRef.current?.timeScale().applyOptions({
          barSpacing: 3
        });
        return;
      }
      if (currentTf === "12h" && barSpacing > TIMEFRAME_SWITCH_THRESHOLDS["12h"].zoomIn) {
        logger8.info(
          `[SWITCH] 12h bar spacing ${barSpacing} > ${TIMEFRAME_SWITCH_THRESHOLDS["12h"].zoomIn} \u2192 switching to 4h`
        );
        switchTimeframe("4h");
      } else if (currentTf === "4h" && barSpacing < TIMEFRAME_SWITCH_THRESHOLDS["4h"].zoomOut) {
        logger8.info(
          `[SWITCH] 4h bar spacing ${barSpacing} < ${TIMEFRAME_SWITCH_THRESHOLDS["4h"].zoomOut} \u2192 switching to 12h`
        );
        switchTimeframe("12h");
      } else if (currentTf === "4h" && barSpacing > TIMEFRAME_SWITCH_THRESHOLDS["4h"].zoomIn) {
        logger8.info(
          `[SWITCH] 4h bar spacing ${barSpacing} > ${TIMEFRAME_SWITCH_THRESHOLDS["4h"].zoomIn} \u2192 switching to 1h`
        );
        switchTimeframe("1h");
      } else if (currentTf === "1h" && barSpacing < TIMEFRAME_SWITCH_THRESHOLDS["1h"].zoomOut) {
        logger8.info(
          `[SWITCH] 1h bar spacing ${barSpacing} < ${TIMEFRAME_SWITCH_THRESHOLDS["1h"].zoomOut} \u2192 switching to 4h`
        );
        switchTimeframe("4h");
      } else if (currentTf === "1h" && barSpacing > TIMEFRAME_SWITCH_THRESHOLDS["1h"].zoomIn) {
        logger8.info(
          `[SWITCH] 1h bar spacing ${barSpacing} > ${TIMEFRAME_SWITCH_THRESHOLDS["1h"].zoomIn} \u2192 switching to 15m`
        );
        switchTimeframe("15m");
      } else if (currentTf === "15m" && barSpacing < TIMEFRAME_SWITCH_THRESHOLDS["15m"].zoomOut) {
        logger8.info(
          `[SWITCH] 15m bar spacing ${barSpacing} < ${TIMEFRAME_SWITCH_THRESHOLDS["15m"].zoomOut} \u2192 switching to 1h`
        );
        switchTimeframe("1h");
      } else if (currentTf === "15m" && barSpacing > TIMEFRAME_SWITCH_THRESHOLDS["15m"].zoomIn) {
        logger8.info(
          `[SWITCH] 15m bar spacing ${barSpacing} > ${TIMEFRAME_SWITCH_THRESHOLDS["15m"].zoomIn} \u2192 switching to 5m`
        );
        switchTimeframe("5m");
      } else if (currentTf === "5m" && barSpacing < TIMEFRAME_SWITCH_THRESHOLDS["5m"].zoomOut) {
        logger8.info(
          `[SWITCH] 5m bar spacing ${barSpacing} < ${TIMEFRAME_SWITCH_THRESHOLDS["5m"].zoomOut} \u2192 switching to 15m`
        );
        switchTimeframe("15m");
      }
    };
    checkIntervalRef.current = setInterval(() => {
      if (!chartRef.current) {
        logger8.debug("[ResolutionTracker] Chart not ready");
        return;
      }
      if (isTransitioningRef.current) {
        logger8.debug("[ResolutionTracker] Skipping check - transition in progress");
        return;
      }
      try {
        const currentBarSpacing = chartRef.current.timeScale().options().barSpacing;
        if (currentBarSpacing !== lastBarSpacing && !isTransitioningRef.current) {
          logger8.debug(
            `[ResolutionTracker] Current timeframe: ${currentTimeframeRef.current}, bar spacing: ${currentBarSpacing} (was: ${lastBarSpacing})`
          );
          logger8.debug(`[ResolutionTracker] isTransitioningRef.current = ${isTransitioningRef.current}`);
          logger8.debug(`[ResolutionTracker] About to call checkTimeframeSwitch`);
          lastBarSpacing = currentBarSpacing;
          checkTimeframeSwitch(currentBarSpacing);
        }
      } catch (e) {
        logger8.error("[ResolutionTracker] Error in interval:", e);
        if (checkIntervalRef.current) {
          clearInterval(checkIntervalRef.current);
          checkIntervalRef.current = null;
        }
      }
    }, 100);
    const handleKeyDown = (e) => {
      if (e.key === "Shift" && !isShiftPressed) {
        setIsShiftPressed(true);
        const timeScale = chartRef.current?.timeScale();
        if (timeScale) {
          const visibleRange = timeScale.getVisibleRange();
          if (visibleRange) {
            lockedLeftEdgeRef.current = visibleRange.from;
            logger8.debug(
              "[LOCK LEFT] Activated, locking left edge at:",
              new Date(visibleRange.from * 1e3).toISOString()
            );
            timeScale.applyOptions({
              rightBarStaysOnScroll: false
            });
          }
        }
      }
    };
    const handleKeyUp = (e) => {
      if (e.key === "Shift") {
        setIsShiftPressed(false);
        lockedLeftEdgeRef.current = null;
        logger8.debug("[LOCK LEFT] Released, re-enabling right lock");
        chartRef.current?.timeScale().applyOptions({
          rightBarStaysOnScroll: true
        });
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      if (checkIntervalRef.current) {
        clearInterval(checkIntervalRef.current);
      }
      if (crosshairUnsubscribe && typeof crosshairUnsubscribe === "function") {
        crosshairUnsubscribe();
      }
      if (toolTip && toolTip.parentNode) {
        toolTip.parentNode.removeChild(toolTip);
      }
      if (watermarkRef.current && candlestickSeries) {
        candlestickSeries.detachPrimitive(watermarkRef.current);
        watermarkRef.current = null;
      }
      if (countdownTimerRef.current && candlestickSeries) {
        candlestickSeries.detachPrimitive(countdownTimerRef.current);
        countdownTimerRef.current = null;
      }
      chart.remove();
    };
  }, []);
  React3.useEffect(() => {
    if (initialLoadDoneRef.current) {
      logger8.debug("Initial load already done, skipping");
      return;
    }
    let mounted = true;
    const loadInitialData = async () => {
      if (!mounted || initialLoadDoneRef.current || !seriesRef.current || !chartRef.current || !symbol)
        return;
      logger8.info("Initial load triggered");
      initialLoadDoneRef.current = true;
      setIsLoading(true);
      setError(null);
      symbolRef.current = symbol;
      currentTimeframeRef.current = timeframe || "1h";
      try {
        const { data } = await fetchChartData(
          symbol || "EURUSD",
          currentTimeframeRef.current
          // NO from/to - coordinator handles full range calculation
        );
        if (data.length > 0) {
          if (seriesRef.current && !hasPlaceholder()) {
            seriesRef.current.setData(data.map((d) => ({ ...d, time: d.time })));
          } else {
            updateWithRealData(data.map((d) => ({ ...d, time: d.time })));
          }
          if (chartRef.current && data.length > 0) {
            const daysToShow = getDaysToShowForTimeframe(currentTimeframeRef.current);
            const lastDataTime = data[data.length - 1].time;
            const from = lastDataTime - daysToShow * 24 * 60 * 60;
            chartRef.current.timeScale().setVisibleRange({
              from,
              to: lastDataTime
            });
            logger8.debug(`Set visible range to ${daysToShow} days ending at data time ${new Date(lastDataTime * 1e3).toISOString()}`);
          }
        }
      } catch (error) {
        logger8.error("Error loading market chart data:", error);
        setError(error instanceof Error ? error : new Error("Failed to load chart data"));
      } finally {
        setIsLoading(false);
      }
    };
    loadInitialData();
    return () => {
      mounted = false;
    };
  }, []);
  React3.useEffect(() => {
    if (!preloadAdjacentTimeframes || !initialLoadDoneRef.current || !symbol) {
      return;
    }
    const preloadAllTimeframes = async () => {
      const currentTf = currentTimeframeRef.current;
      const timeframesToPreload = ALL_TIMEFRAMES.filter((tf) => tf !== currentTf);
      logger8.info(`Preloading all timeframes: ${timeframesToPreload.join(", ")}`);
      Promise.all(
        timeframesToPreload.map(async (tf) => {
          try {
            await chartDataCoordinator.fetchChartData(symbol, tf, { forceRefresh: false });
            logger8.debug(`Preloaded ${tf} data for ${symbol}`);
          } catch (error) {
            logger8.warn(`Failed to preload ${tf} data:`, error);
          }
        })
      ).then(() => {
        logger8.info(`All timeframe preloading complete`);
      });
    };
    const timeoutId = setTimeout(preloadAllTimeframes, 500);
    return () => clearTimeout(timeoutId);
  }, [preloadAdjacentTimeframes, symbol, isLoading]);
  React3.useEffect(() => {
    if (timeframe && timeframe !== currentTimeframeRef.current && !isTransitioningRef.current && initialLoadDoneRef.current) {
      logger8.info(`[EXTERNAL] Switching to ${timeframe} from external control`);
      switchTimeframe(timeframe);
    }
  }, [timeframe]);
  React3.useEffect(() => {
    if (!symbol) return;
    const prevSymbol = symbolRef.current;
    symbolRef.current = symbol;
    if (prevSymbol !== symbol && chartRef.current && initialLoadDoneRef.current && prevSymbol !== void 0) {
      logger8.info("Symbol changed from", prevSymbol, "to", symbol);
      if (seriesRef.current) {
        logger8.debug("Clearing chart data for symbol change");
        seriesRef.current.setData([]);
      }
      setIsLoading(true);
      setError(null);
      if (resetTrigger) {
        resetTrigger();
      }
      fetchChartData(symbol, currentTimeframeRef.current).then(({ data }) => {
        if (data.length > 0 && seriesRef.current) {
          seriesRef.current.setData(data.map((d) => ({ ...d, time: d.time })));
        }
      }).catch((error) => {
        logger8.error("Error loading new symbol:", error);
        setError(error instanceof Error ? error : new Error("Failed to load symbol data"));
      }).finally(() => setIsLoading(false));
    }
  }, [symbol]);
  if (isLoading && !initialLoadDoneRef.current) {
    return /* @__PURE__ */ jsxRuntime.jsx(ChartErrorBoundary, { children: /* @__PURE__ */ jsxRuntime.jsx(core.Box, { style: { position: "relative", width: "100%", height: "100%" }, children: /* @__PURE__ */ jsxRuntime.jsx(ChartSkeleton, { height: "100%" }) }) });
  }
  if (!symbol) {
    return /* @__PURE__ */ jsxRuntime.jsx(ChartErrorBoundary, { children: /* @__PURE__ */ jsxRuntime.jsx(core.Box, { style: { position: "relative", width: "100%", height: "100%" }, children: /* @__PURE__ */ jsxRuntime.jsx(ChartEmptyState, {}) }) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ChartErrorBoundary, { onError: (err) => setError(err), children: /* @__PURE__ */ jsxRuntime.jsx(core.Box, { style: { position: "relative", width: "100%", height: "100%" }, children: /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      ref: chartContainerRef,
      style: {
        width: "100%",
        height: "100%",
        background: "#0a0a0a",
        position: "relative",
        opacity: 1
        // Always full opacity to prevent flashing
        // transition: 'opacity 300ms ease-in-out',
      },
      children: [
        isLoading && /* @__PURE__ */ jsxRuntime.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              right: "10px",
              background: "rgba(0,0,0,0.7)",
              color: "#fff",
              padding: "5px 10px",
              borderRadius: "4px",
              fontSize: "12px"
            },
            children: "Loading..."
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              left: "10px",
              background: "rgba(0,0,0,0.7)",
              color: "#00ff88",
              padding: "5px 10px",
              borderRadius: "4px",
              fontSize: "12px",
              fontFamily: "monospace"
            },
            children: [
              currentTimeframe,
              isShiftPressed && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { marginLeft: "10px", color: "#ff9900" }, children: "[LOCK LEFT]" })
            ]
          }
        )
      ]
    }
  ) }) });
};
var MarketDataChart_default = MarketDataChart;
var logger9 = createLogger("StreamStatus");
var statusConfig = {
  connected: {
    color: "#4caf50",
    bgColor: "rgba(76, 175, 80, 0.1)",
    icon: "\u25CF",
    label: "Connected"
  },
  connecting: {
    color: "#2196f3",
    bgColor: "rgba(33, 150, 243, 0.1)",
    icon: "\u25D0",
    label: "Connecting",
    animate: true
  },
  disconnected: {
    color: "#757575",
    bgColor: "rgba(117, 117, 117, 0.1)",
    icon: "\u25CB",
    label: "Disconnected"
  },
  error: {
    color: "#f44336",
    bgColor: "rgba(244, 67, 54, 0.1)",
    icon: "\u2715",
    label: "Error"
  },
  reconnecting: {
    color: "#ff9800",
    bgColor: "rgba(255, 152, 0, 0.1)",
    icon: "\u21BB",
    label: "Reconnecting",
    animate: true
  }
};
var StreamStatus = ({
  status,
  symbol,
  message,
  onRetry,
  position = "top-right",
  compact = false
}) => {
  const config = statusConfig[status];
  React3__default.default.useEffect(() => {
    logger9.debug(`Status changed to: ${status}`, { symbol, message });
  }, [status, symbol, message]);
  const positionStyles = {
    "top-left": { top: 10, left: 10 },
    "top-right": { top: 10, right: 10 },
    "bottom-left": { bottom: 10, left: 10 },
    "bottom-right": { bottom: 10, right: 10 }
  };
  const handleRetry = () => {
    logger9.info("Retry connection requested");
    onRetry?.();
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        ...positionStyles[position],
        padding: compact ? "4px 8px" : "8px 12px",
        borderRadius: "4px",
        backgroundColor: config.bgColor,
        border: `1px solid ${config.color}`,
        display: "flex",
        alignItems: "center",
        gap: "8px",
        fontSize: compact ? "12px" : "14px",
        fontFamily: "system-ui, -apple-system, sans-serif",
        zIndex: 1e3,
        userSelect: "none",
        transition: "all 0.3s ease"
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "span",
          {
            style: {
              color: config.color,
              fontSize: compact ? "12px" : "16px",
              animation: config.animate ? "pulse 1.5s infinite" : "none"
            },
            children: config.icon
          }
        ),
        !compact && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: config.color, fontWeight: 500 }, children: config.label }),
          symbol && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: config.color, opacity: 0.8 }, children: symbol }),
          message && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: config.color, opacity: 0.7, fontSize: "12px" }, children: message }),
          (status === "error" || status === "disconnected") && onRetry && /* @__PURE__ */ jsxRuntime.jsx(
            "button",
            {
              onClick: handleRetry,
              style: {
                marginLeft: "8px",
                padding: "2px 8px",
                fontSize: "12px",
                color: config.color,
                backgroundColor: "transparent",
                border: `1px solid ${config.color}`,
                borderRadius: "3px",
                cursor: "pointer",
                transition: "all 0.2s ease"
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.backgroundColor = config.color;
                e.currentTarget.style.color = "#ffffff";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.backgroundColor = "transparent";
                e.currentTarget.style.color = config.color;
              },
              children: "Retry"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx("style", { children: `
          @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
          }
        ` })
      ]
    }
  );
};
var MinimalStreamStatus = ({ status }) => {
  const config = statusConfig[status];
  return /* @__PURE__ */ jsxRuntime.jsx(
    "span",
    {
      style: {
        color: config.color,
        fontSize: "14px",
        animation: config.animate ? "pulse 1.5s infinite" : "none"
      },
      title: config.label,
      children: config.icon
    }
  );
};
var logger10 = createLogger("useChartSetup");
var darkTheme = {
  backgroundColor: "#0d0d0d",
  textColor: "#d1d4dc",
  gridColor: "rgba(42, 46, 57, 0.6)",
  borderColor: "#2a2e39",
  upColor: "#26a69a",
  downColor: "#ef5350",
  wickUpColor: "#26a69a",
  wickDownColor: "#ef5350"
};
var defaultChartOptions = (theme) => ({
  layout: {
    background: { color: theme.backgroundColor },
    textColor: theme.textColor
  },
  grid: {
    vertLines: { color: theme.gridColor },
    horzLines: { color: theme.gridColor }
  },
  crosshair: {
    mode: 0,
    // Normal mode - free mouse movement
    vertLine: {
      color: theme.gridColor,
      width: 1,
      style: 3,
      // Dashed
      labelBackgroundColor: theme.borderColor
    },
    horzLine: {
      color: theme.gridColor,
      width: 1,
      style: 3,
      // Dashed
      labelBackgroundColor: theme.borderColor
    }
  },
  rightPriceScale: {
    borderColor: theme.borderColor,
    scaleMargins: {
      top: 0.1,
      bottom: 0.2
    }
  },
  timeScale: {
    borderColor: theme.borderColor,
    timeVisible: true,
    secondsVisible: false,
    rightBarStaysOnScroll: true,
    barSpacing: 12,
    minBarSpacing: 2,
    fixRightEdge: false,
    fixLeftEdge: false,
    lockVisibleTimeRangeOnResize: false
  },
  handleScroll: {
    mouseWheel: true,
    pressedMouseMove: true,
    horzTouchDrag: true,
    vertTouchDrag: false
  },
  handleScale: {
    axisPressedMouseMove: {
      time: true,
      price: true
    },
    axisDoubleClickReset: true,
    mouseWheel: true,
    pinch: true
  }
});
var defaultSeriesOptions = (theme) => ({
  upColor: theme.upColor,
  downColor: theme.downColor,
  borderVisible: false,
  wickUpColor: theme.wickUpColor,
  wickDownColor: theme.wickDownColor,
  priceFormat: {
    type: "price",
    precision: 5,
    minMove: 1e-5
  },
  priceScaleId: "right",
  lastValueVisible: true,
  priceLineVisible: true
});
function useChartSetup(containerRef, options) {
  const chartRef = React3.useRef(null);
  const seriesRef = React3.useRef(null);
  const isReadyRef = React3.useRef(false);
  const theme = options?.theme || darkTheme;
  const chartOptions = options?.chartOptions || {};
  const seriesOptions = options?.seriesOptions || {};
  React3.useEffect(() => {
    if (!containerRef.current) return;
    logger10.debug("Creating chart");
    const chart = lightweightCharts.createChart(containerRef.current, {
      width: containerRef.current.clientWidth,
      height: containerRef.current.clientHeight,
      ...defaultChartOptions(theme),
      ...chartOptions
    });
    const series = chart.addCandlestickSeries({
      ...defaultSeriesOptions(theme),
      ...seriesOptions
    });
    chartRef.current = chart;
    seriesRef.current = series;
    isReadyRef.current = true;
    logger10.debug("Chart created successfully");
    return () => {
      logger10.debug("Cleaning up chart");
      isReadyRef.current = false;
      chart.remove();
      chartRef.current = null;
      seriesRef.current = null;
    };
  }, []);
  React3.useEffect(() => {
    if (!chartRef.current || !containerRef.current) return;
    const resizeObserver = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (entry && chartRef.current) {
        const { width, height } = entry.contentRect;
        chartRef.current.applyOptions({ width, height });
      }
    });
    resizeObserver.observe(containerRef.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  return {
    chart: chartRef.current,
    series: seriesRef.current,
    isReady: isReadyRef.current
  };
}
var logger11 = createLogger("useChartZoom");
function useChartZoom(chart, options) {
  const [isShiftPressed, setIsShiftPressed] = React3.useState(false);
  const [lockedLeftEdge, setLockedLeftEdge] = React3.useState(null);
  const [visibleRange, setVisibleRange] = React3.useState(null);
  const [barSpacing, setBarSpacing] = React3.useState(12);
  const barSpacingCheckInterval = options?.barSpacingCheckInterval || 100;
  const lastBarSpacingRef = React3.useRef(12);
  React3.useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Shift" && !isShiftPressed) {
        setIsShiftPressed(true);
        if (chart && visibleRange) {
          setLockedLeftEdge(visibleRange.from);
          logger11.debug(
            "Left edge locked at:",
            new Date(visibleRange.from * 1e3).toISOString()
          );
          chart.timeScale().applyOptions({
            rightBarStaysOnScroll: false
          });
        }
      }
    };
    const handleKeyUp = (e) => {
      if (e.key === "Shift" && isShiftPressed) {
        setIsShiftPressed(false);
        setLockedLeftEdge(null);
        logger11.debug("Left edge lock released");
        if (chart) {
          chart.timeScale().applyOptions({
            rightBarStaysOnScroll: true
          });
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      if (isShiftPressed && chart) {
        chart.timeScale().applyOptions({
          rightBarStaysOnScroll: true
        });
      }
    };
  }, [chart, isShiftPressed, visibleRange]);
  React3.useEffect(() => {
    if (!chart) return;
    const handleVisibleRangeChange = () => {
      const range = chart.timeScale().getVisibleRange();
      if (range) {
        const newRange = {
          from: range.from,
          to: range.to
        };
        setVisibleRange(newRange);
        options?.onVisibleRangeChange?.(newRange);
      } else {
        setVisibleRange(null);
        options?.onVisibleRangeChange?.(null);
      }
    };
    handleVisibleRangeChange();
    chart.timeScale().subscribeVisibleTimeRangeChange(handleVisibleRangeChange);
    return () => {
      chart.timeScale().unsubscribeVisibleTimeRangeChange(handleVisibleRangeChange);
    };
  }, [chart, options]);
  React3.useEffect(() => {
    if (!chart) return;
    const checkBarSpacing = () => {
      try {
        const currentBarSpacing = chart.timeScale().options().barSpacing;
        if (currentBarSpacing !== lastBarSpacingRef.current) {
          logger11.debug(
            `Bar spacing changed: ${lastBarSpacingRef.current} \u2192 ${currentBarSpacing}`
          );
          lastBarSpacingRef.current = currentBarSpacing;
          setBarSpacing(currentBarSpacing);
          options?.onBarSpacingChange?.(currentBarSpacing);
        }
      } catch (e) {
        logger11.error("Error checking bar spacing:", e);
      }
    };
    const intervalId = setInterval(checkBarSpacing, barSpacingCheckInterval);
    return () => clearInterval(intervalId);
  }, [chart, barSpacingCheckInterval, options]);
  const zoomIn = React3.useCallback((factor = 1.2) => {
    if (!chart) return;
    const timeScale = chart.timeScale();
    const currentBarSpacing = timeScale.options().barSpacing;
    const newBarSpacing = Math.min(currentBarSpacing * factor, 50);
    timeScale.applyOptions({ barSpacing: newBarSpacing });
  }, [chart]);
  const zoomOut = React3.useCallback((factor = 1.2) => {
    if (!chart) return;
    const timeScale = chart.timeScale();
    const currentBarSpacing = timeScale.options().barSpacing;
    const newBarSpacing = Math.max(currentBarSpacing / factor, 2);
    timeScale.applyOptions({ barSpacing: newBarSpacing });
  }, [chart]);
  const resetZoom = React3.useCallback(() => {
    if (!chart) return;
    chart.timeScale().fitContent();
  }, [chart]);
  const scrollToTime2 = React3.useCallback((time, animate = true) => {
    if (!chart || !visibleRange) return;
    const duration = visibleRange.to - visibleRange.from;
    const newFrom = time - duration / 2;
    const newTo = time + duration / 2;
    chart.timeScale().setVisibleRange({
      from: newFrom,
      to: newTo
    });
    if (animate) {
      chart.timeScale().scrollToRealTime();
    }
  }, [chart, visibleRange]);
  const setVisibleRangeCallback = React3.useCallback((range) => {
    if (!chart) return;
    chart.timeScale().setVisibleRange({
      from: range.from,
      to: range.to
    });
  }, [chart]);
  const maintainLeftEdgeLock = React3.useCallback(() => {
    if (!chart || !isShiftPressed || lockedLeftEdge === null || !visibleRange) return;
    const currentDuration = visibleRange.to - visibleRange.from;
    const newTo = lockedLeftEdge + currentDuration;
    chart.timeScale().setVisibleRange({
      from: lockedLeftEdge,
      to: newTo
    });
  }, [chart, isShiftPressed, lockedLeftEdge, visibleRange]);
  return {
    isShiftPressed,
    lockedLeftEdge,
    visibleRange,
    barSpacing,
    zoomIn,
    zoomOut,
    resetZoom,
    scrollToTime: scrollToTime2,
    setVisibleRange: setVisibleRangeCallback,
    maintainLeftEdgeLock
  };
}
var logger12 = createLogger("useChartData");
function useChartData(symbol, timeframe, options) {
  const [data, setData] = React3.useState([]);
  const [isLoading, setIsLoading] = React3.useState(false);
  const [error, setError] = React3.useState(null);
  const currentRef = React3.useRef({ symbol, timeframe });
  const fetchData = React3.useCallback(async (fetchOptions) => {
    if (isLoading) {
      logger12.trace("Already loading, skipping fetch");
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      const result = await chartDataCoordinator.fetchChartData(
        symbol,
        timeframe,
        {
          forceRefresh: fetchOptions?.forceRefresh,
          range: fetchOptions?.range || options?.range
        }
      );
      if (currentRef.current.symbol === symbol && currentRef.current.timeframe === timeframe) {
        setData(result);
        logger12.debug(`Updated data for ${symbol}-${timeframe}: ${result.length} candles`);
      }
    } catch (err) {
      logger12.error("Fetch error:", err);
      if (currentRef.current.symbol === symbol && currentRef.current.timeframe === timeframe) {
        setError(err instanceof Error ? err.message : "Failed to fetch data");
      }
    } finally {
      if (currentRef.current.symbol === symbol && currentRef.current.timeframe === timeframe) {
        setIsLoading(false);
      }
    }
  }, [symbol, timeframe, isLoading, options?.range]);
  const setDefaultRange = React3.useCallback((from, to) => {
    chartDataCoordinator.setDefaultRange(symbol, timeframe, from, to);
  }, [symbol, timeframe]);
  const invalidateCache = React3.useCallback((pattern) => {
    chartDataCoordinator.invalidateCache(pattern);
  }, []);
  React3.useEffect(() => {
    currentRef.current = { symbol, timeframe };
    setData([]);
    if (options?.autoLoad !== false) {
      fetchData();
    }
  }, [symbol, timeframe, options?.autoLoad]);
  React3.useEffect(() => {
    return () => {
      logger12.trace(`Unmounting for ${symbol}-${timeframe}`);
    };
  }, [symbol, timeframe]);
  return {
    data,
    isLoading,
    error,
    fetchData,
    invalidateCache,
    setDefaultRange
  };
}
function useCountdownTimer(timeframe, options) {
  const {
    onNewCandleBoundary,
    updateInterval = 1e3,
    warningThreshold = 30,
    criticalThreshold = 10
  } = options || {};
  const [countdown, setCountdown] = React3.useState("00:00");
  const [countdownColor, setCountdownColor] = React3.useState("#999");
  const [secondsRemaining, setSecondsRemaining] = React3.useState(0);
  const intervalRef = React3.useRef(null);
  const lastUpdateRef = React3.useRef(0);
  const hasTriggeredRef = React3.useRef(false);
  const calculateSecondsToNextCandle = React3.useCallback((timeframe2) => {
    const now = /* @__PURE__ */ new Date();
    const seconds = now.getUTCSeconds();
    const minutes = now.getUTCMinutes();
    const hours = now.getUTCHours();
    switch (timeframe2) {
      case "5m":
        return (5 - minutes % 5) * 60 - seconds;
      case "15m":
        return (15 - minutes % 15) * 60 - seconds;
      case "1h":
        return (60 - minutes) * 60 - seconds;
      case "4h":
        return (4 - hours % 4) * 3600 + (60 - minutes) * 60 - seconds;
      case "12h":
        return (12 - hours % 12) * 3600 + (60 - minutes) * 60 - seconds;
      default:
        return (60 - minutes) * 60 - seconds;
    }
  }, []);
  const formatCountdown = React3.useCallback((totalSeconds) => {
    const displaySeconds = Math.max(0, totalSeconds);
    const minutes = Math.floor(displaySeconds / 60);
    const seconds = displaySeconds % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }, []);
  const getCountdownColor = React3.useCallback((seconds) => {
    if (seconds <= criticalThreshold) {
      return "#ffae00";
    } else if (seconds <= warningThreshold) {
      return "#ccc";
    } else {
      return "#999";
    }
  }, [criticalThreshold, warningThreshold]);
  const updateCountdown = React3.useCallback(() => {
    const now = Date.now();
    const seconds = Math.floor(now / 1e3) % 60;
    const nearBoundary = seconds >= 58 || seconds <= 2;
    const throttleMs = nearBoundary ? 100 : 950;
    if (now - lastUpdateRef.current < throttleMs) return;
    lastUpdateRef.current = now;
    const totalSeconds = calculateSecondsToNextCandle(timeframe);
    setSecondsRemaining(totalSeconds);
    setCountdown(formatCountdown(totalSeconds));
    setCountdownColor(getCountdownColor(totalSeconds));
    if (totalSeconds <= 0 && !hasTriggeredRef.current) {
      hasTriggeredRef.current = true;
      const candleTime = Math.floor(now / 1e3);
      onNewCandleBoundary?.(candleTime);
    }
    if (totalSeconds > 5) {
      hasTriggeredRef.current = false;
    }
  }, [timeframe, calculateSecondsToNextCandle, formatCountdown, getCountdownColor, onNewCandleBoundary]);
  React3.useEffect(() => {
    const startCountdown = () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      updateCountdown();
      intervalRef.current = setInterval(updateCountdown, updateInterval);
    };
    const stopCountdown = () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
    const handleVisibilityChange = () => {
      if (document.hidden) {
        stopCountdown();
      } else {
        startCountdown();
      }
    };
    if (!document.hidden) {
      startCountdown();
    }
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      stopCountdown();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [timeframe, updateCountdown, updateInterval]);
  return {
    countdown,
    countdownColor,
    secondsRemaining,
    isNearBoundary: secondsRemaining <= 2 && secondsRemaining > 0,
    isPastBoundary: secondsRemaining <= 0
  };
}
function getNextCandleTime(timeframe) {
  const now = Math.floor(Date.now() / 1e3);
  const period = TIMEFRAME_SECONDS[timeframe] || TIMEFRAME_SECONDS["1h"];
  return Math.ceil(now / period) * period;
}
function getCurrentCandleTime(timeframe) {
  const now = Math.floor(Date.now() / 1e3);
  const period = TIMEFRAME_SECONDS[timeframe] || TIMEFRAME_SECONDS["1h"];
  return Math.floor(now / period) * period;
}

// src/services/ReconnectionManager.ts
var logger13 = createLogger("ReconnectionManager");
var ReconnectionManager = class {
  constructor(connectFunction, config = {}) {
    this.retryCount = 0;
    this.isDestroyed = false;
    this.currentStatus = "disconnected";
    this.connectFn = connectFunction;
    this.config = {
      maxRetries: config.maxRetries ?? 10,
      initialDelay: config.initialDelay ?? 1e3,
      maxDelay: config.maxDelay ?? 3e4,
      backoffMultiplier: config.backoffMultiplier ?? 1.5,
      onStatusChange: config.onStatusChange ?? (() => {
      }),
      onError: config.onError ?? (() => {
      }),
      onConnected: config.onConnected ?? (() => {
      }),
      onDisconnected: config.onDisconnected ?? (() => {
      }),
      onMaxRetriesReached: config.onMaxRetriesReached ?? (() => {
      })
    };
    this.currentDelay = this.config.initialDelay;
  }
  setStatus(status) {
    if (this.currentStatus !== status) {
      this.currentStatus = status;
      logger13.info(`Status changed: ${status}`);
      this.config.onStatusChange(status);
    }
  }
  async connect() {
    if (this.isDestroyed) {
      logger13.warn("Cannot connect: ReconnectionManager is destroyed");
      return;
    }
    this.clearRetryTimer();
    this.setStatus("connecting");
    try {
      await this.connectFn();
      this.handleConnectionSuccess();
    } catch (error) {
      this.handleConnectionError(error);
    }
  }
  handleConnectionSuccess() {
    logger13.info("Connection successful");
    this.retryCount = 0;
    this.currentDelay = this.config.initialDelay;
    this.setStatus("connected");
    this.config.onConnected();
  }
  handleConnectionError(error) {
    logger13.error("Connection failed:", error);
    this.config.onError(error, this.retryCount);
    if (this.retryCount >= this.config.maxRetries) {
      this.handleMaxRetriesReached();
      return;
    }
    this.scheduleRetry();
  }
  handleMaxRetriesReached() {
    logger13.error(`Max retries (${this.config.maxRetries}) reached`);
    this.setStatus("error");
    this.config.onMaxRetriesReached();
  }
  scheduleRetry() {
    if (this.isDestroyed) return;
    this.retryCount++;
    this.setStatus("reconnecting");
    logger13.info(`Scheduling retry ${this.retryCount}/${this.config.maxRetries} in ${this.currentDelay}ms`);
    this.retryTimer = setTimeout(() => {
      this.connect();
    }, this.currentDelay);
    this.currentDelay = Math.min(
      this.currentDelay * this.config.backoffMultiplier,
      this.config.maxDelay
    );
  }
  disconnect(reason) {
    logger13.info("Disconnecting", reason ? `Reason: ${reason}` : "");
    this.clearRetryTimer();
    this.setStatus("disconnected");
    this.config.onDisconnected(reason);
  }
  clearRetryTimer() {
    if (this.retryTimer) {
      clearTimeout(this.retryTimer);
      this.retryTimer = void 0;
    }
  }
  resetRetryCount() {
    this.retryCount = 0;
    this.currentDelay = this.config.initialDelay;
  }
  getStatus() {
    return this.currentStatus;
  }
  getRetryCount() {
    return this.retryCount;
  }
  getNextRetryDelay() {
    return this.currentDelay;
  }
  destroy() {
    logger13.info("Destroying ReconnectionManager");
    this.isDestroyed = true;
    this.clearRetryTimer();
    this.disconnect("Manager destroyed");
  }
};
var WebSocketReconnectionManager = class extends ReconnectionManager {
  // 5 seconds
  constructor(url, protocols, config) {
    const wsConfig = { ...config };
    const onMessage = wsConfig.onMessage;
    delete wsConfig.onMessage;
    super(async () => {
      await this.createWebSocket(onMessage);
    }, wsConfig);
    this.pingInterval = 3e4;
    // 30 seconds
    this.pongTimeout = 5e3;
    this.url = url;
    this.protocols = protocols;
    if (config?.enableHeartbeat) {
      this.pingInterval = config.pingInterval ?? this.pingInterval;
      this.pongTimeout = config.pongTimeout ?? this.pongTimeout;
    } else {
      this.pingInterval = void 0;
      this.pongTimeout = void 0;
    }
  }
  async createWebSocket(onMessage) {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.url, this.protocols);
        this.ws.onopen = () => {
          logger13.info("WebSocket connected");
          this.startHeartbeat();
          resolve();
        };
        this.ws.onerror = (event) => {
          logger13.error("WebSocket error:", event);
          reject(new Error("WebSocket connection failed"));
        };
        this.ws.onclose = (event) => {
          logger13.info("WebSocket closed:", { code: event.code, reason: event.reason });
          this.stopHeartbeat();
          if (event.code !== 1e3 && event.code !== 1001) {
            this.disconnect("WebSocket closed unexpectedly");
            this.connect();
          }
        };
        if (onMessage) {
          this.ws.onmessage = onMessage;
        }
        this.ws.addEventListener("message", (event) => {
          if (event.data === "pong") {
            this.handlePong();
          }
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  startHeartbeat() {
    if (!this.pingInterval) return;
    this.heartbeatInterval = setInterval(() => {
      this.sendPing();
    }, this.pingInterval);
  }
  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = void 0;
    }
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
      this.heartbeatTimeout = void 0;
    }
  }
  sendPing() {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.lastPingTime = Date.now();
      this.ws.send("ping");
      this.heartbeatTimeout = setTimeout(() => {
        logger13.warn("Heartbeat timeout - no pong received");
        this.ws?.close();
      }, this.pongTimeout);
    }
  }
  handlePong() {
    if (this.heartbeatTimeout) {
      clearTimeout(this.heartbeatTimeout);
      this.heartbeatTimeout = void 0;
    }
    if (this.lastPingTime) {
      const latency = Date.now() - this.lastPingTime;
      logger13.trace(`Heartbeat latency: ${latency}ms`);
    }
  }
  send(data) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(data);
    } else {
      logger13.warn("Cannot send: WebSocket is not open");
    }
  }
  close(code, reason) {
    this.stopHeartbeat();
    this.ws?.close(code, reason);
    this.destroy();
  }
  getWebSocket() {
    return this.ws;
  }
};

// src/hooks/useReconnection.ts
var logger14 = createLogger("useReconnection");
function useReconnection(connectFn, options = {}) {
  const { enabled = true, autoConnect = true, ...config } = options;
  const [status, setStatus] = React3.useState("disconnected");
  const [retryCount, setRetryCount] = React3.useState(0);
  const [nextRetryDelay, setNextRetryDelay] = React3.useState(0);
  const managerRef = React3.useRef();
  React3.useEffect(() => {
    if (!enabled) return;
    const manager = new ReconnectionManager(connectFn, {
      ...config,
      onStatusChange: (newStatus) => {
        setStatus(newStatus);
        setRetryCount(manager.getRetryCount());
        setNextRetryDelay(manager.getNextRetryDelay());
        config.onStatusChange?.(newStatus);
      }
    });
    managerRef.current = manager;
    if (autoConnect) {
      manager.connect();
    }
    return () => {
      manager.destroy();
    };
  }, [enabled]);
  const connect = React3.useCallback(async () => {
    await managerRef.current?.connect();
  }, []);
  const disconnect = React3.useCallback((reason) => {
    managerRef.current?.disconnect(reason);
  }, []);
  const resetRetries = React3.useCallback(() => {
    managerRef.current?.resetRetryCount();
    setRetryCount(0);
    setNextRetryDelay(config.initialDelay || 1e3);
  }, [config.initialDelay]);
  return {
    status,
    retryCount,
    nextRetryDelay,
    connect,
    disconnect,
    resetRetries
  };
}
function useWebSocketReconnection(options) {
  const {
    url,
    protocols,
    enableHeartbeat = true,
    pingInterval,
    pongTimeout,
    onMessage,
    onOpen,
    onClose,
    onError,
    onWebSocketError,
    enabled = true,
    autoConnect = true,
    ...reconnectionConfig
  } = options;
  const [ws, setWs] = React3.useState();
  const managerRef = React3.useRef();
  React3.useEffect(() => {
    if (!enabled) return;
    const manager = new WebSocketReconnectionManager(url, protocols, {
      ...reconnectionConfig,
      onError,
      enableHeartbeat,
      pingInterval,
      pongTimeout,
      onMessage,
      onConnected: () => {
        const websocket = manager.getWebSocket();
        setWs(websocket);
        if (websocket && onOpen) {
          onOpen(new Event("open"));
        }
        reconnectionConfig.onConnected?.();
      },
      onDisconnected: (reason) => {
        setWs(void 0);
        if (onClose) {
          onClose(new CloseEvent("close", { reason }));
        }
        reconnectionConfig.onDisconnected?.(reason);
      }
    });
    managerRef.current = manager;
    if (autoConnect) {
      manager.connect();
    }
    return () => {
      manager.destroy();
    };
  }, [url, enabled]);
  const reconnectionReturn = useReconnection(
    async () => {
      await Promise.resolve();
    },
    { ...reconnectionConfig, enabled: false }
    // Disable the base hook
  );
  const send = React3.useCallback((data) => {
    managerRef.current?.send(data);
  }, []);
  const close = React3.useCallback((code, reason) => {
    managerRef.current?.close(code, reason);
  }, []);
  return {
    ...reconnectionReturn,
    status: managerRef.current?.getStatus() || "disconnected",
    retryCount: managerRef.current?.getRetryCount() || 0,
    nextRetryDelay: managerRef.current?.getNextRetryDelay() || 0,
    ws,
    send,
    close,
    connect: async () => {
      await managerRef.current?.connect();
    },
    disconnect: (reason) => {
      managerRef.current?.disconnect(reason);
    }
  };
}
function useChartDataStream(symbol, timeframe, onCandle) {
  const wsUrl = `wss://stream.example.com/ws/${symbol.toLowerCase()}@kline_${timeframe}`;
  const { status, send, retryCount } = useWebSocketReconnection({
    url: wsUrl,
    enableHeartbeat: true,
    maxRetries: 10,
    initialDelay: 1e3,
    maxDelay: 3e4,
    onMessage: (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "kline") {
          onCandle(data.kline);
        }
      } catch (error) {
        logger14.error("Failed to parse WebSocket message:", error);
      }
    },
    onConnected: () => {
      logger14.info(`Connected to market data stream for ${symbol}`);
      send(JSON.stringify({
        method: "SUBSCRIBE",
        params: [`${symbol.toLowerCase()}@kline_${timeframe}`],
        id: Date.now()
      }));
    },
    onError: (error, retryCount2) => {
      logger14.error(`Stream error (retry ${retryCount2}):`, error);
    },
    onMaxRetriesReached: () => {
      logger14.error("Failed to connect to market data stream after max retries");
    }
  });
  return { status, retryCount };
}

// src/services/WebSocketService.ts
var logger15 = createLogger("WebSocketService");
var WebSocketService = class {
  constructor(config) {
    this.subscriptions = /* @__PURE__ */ new Map();
    this.isConnected = false;
    this.config = config;
  }
  connect() {
    return new Promise((resolve, reject) => {
      logger15.info("Connecting to WebSocket server...", { url: this.config.url });
      this.manager = new WebSocketReconnectionManager(
        this.config.url,
        void 0,
        {
          enableHeartbeat: this.config.enableHeartbeat ?? true,
          pingInterval: this.config.pingInterval ?? 3e4,
          pongTimeout: this.config.pongTimeout ?? 5e3,
          maxRetries: this.config.maxRetries ?? 10,
          initialDelay: this.config.initialDelay ?? 1e3,
          maxDelay: this.config.maxDelay ?? 3e4,
          onConnected: () => {
            logger15.info("WebSocket connected");
            this.isConnected = true;
            this.sendAuthMessage();
            this.resubscribeAll();
            resolve();
          },
          onDisconnected: (reason) => {
            logger15.warn("WebSocket disconnected", { reason });
            this.isConnected = false;
          },
          onError: (error, retryCount) => {
            logger15.error("WebSocket error", { error, retryCount });
            if (retryCount === 0) {
              reject(error);
            }
          },
          onMessage: (event) => {
            this.handleMessage(event);
          }
        }
      );
      this.manager.connect();
    });
  }
  sendAuthMessage() {
    if (this.config.apiKey) {
      this.send({
        type: "auth",
        apiKey: this.config.apiKey
      });
    }
  }
  resubscribeAll() {
    logger15.info("Resubscribing to all active subscriptions", {
      count: this.subscriptions.size
    });
    this.subscriptions.forEach((sub) => {
      this.sendSubscribeMessage(sub.symbol, sub.timeframe);
    });
  }
  handleMessage(event) {
    try {
      if (event.data === "ping" || event.data === "pong") {
        return;
      }
      const message = JSON.parse(event.data);
      logger15.info("Received WebSocket message", { message });
      this.subscriptions.forEach((sub) => {
        if (sub.onRawMessage) {
          sub.onRawMessage(message);
        }
      });
      if (message.type === "data" && message.data) {
        const innerData = message.data;
        if (innerData.type === "candle" && innerData.data) {
          const candleMessage = {
            type: "candle",
            symbol: message.symbol,
            timeframe: innerData.interval || "1h",
            data: {
              time: innerData.timestamp || innerData.data.time,
              open: innerData.data.open,
              high: innerData.data.high,
              low: innerData.data.low,
              close: innerData.data.close,
              volume: innerData.data.volume
            }
          };
          this.handleCandleUpdate(candleMessage);
        } else if (innerData.type === "tick" && innerData.data) {
          const candleMessage = {
            type: "candle",
            symbol: message.symbol,
            timeframe: "1m",
            // Default timeframe for ticks
            data: {
              time: innerData.timestamp,
              open: innerData.data.price,
              high: innerData.data.price,
              low: innerData.data.price,
              close: innerData.data.price,
              volume: innerData.data.volume
            }
          };
          this.handleCandleUpdate(candleMessage);
        }
      } else if (message.type === "status" || message.type === "subscribed") {
        logger15.info("Status update", { message });
      } else if (message.type === "error") {
        logger15.error("Stream error", { error: message.error || message });
      }
    } catch (error) {
      logger15.error("Failed to parse WebSocket message", { error, data: event.data });
    }
  }
  handleCandleUpdate(message) {
    if (!message.symbol || !message.timeframe || !message.data) {
      logger15.warn("Invalid candle update message", { message });
      return;
    }
    const key = this.getSubscriptionKey(message.symbol, message.timeframe);
    const subscription = this.subscriptions.get(key);
    if (subscription) {
      const candle = {
        time: message.data.time,
        open: message.data.open,
        high: message.data.high,
        low: message.data.low,
        close: message.data.close
      };
      subscription.callback(candle);
    } else {
      logger15.trace("Received update for unsubscribed symbol", {
        symbol: message.symbol,
        timeframe: message.timeframe
      });
    }
  }
  subscribe(symbol, timeframe, callback, onRawMessage) {
    const key = this.getSubscriptionKey(symbol, timeframe);
    if (this.subscriptions.has(key)) {
      logger15.warn("Already subscribed", { symbol, timeframe });
      return () => {
      };
    }
    logger15.info("Subscribing to stream", { symbol, timeframe });
    const subscription = { symbol, timeframe, callback, onRawMessage };
    this.subscriptions.set(key, subscription);
    if (this.isConnected) {
      this.sendSubscribeMessage(symbol, timeframe);
    }
    return () => {
      this.unsubscribe(symbol, timeframe);
    };
  }
  unsubscribe(symbol, timeframe) {
    const key = this.getSubscriptionKey(symbol, timeframe);
    if (!this.subscriptions.has(key)) {
      logger15.warn("Not subscribed", { symbol, timeframe });
      return;
    }
    logger15.info("Unsubscribing from stream", { symbol, timeframe });
    this.subscriptions.delete(key);
    if (this.isConnected) {
      this.sendUnsubscribeMessage(symbol, timeframe);
    }
  }
  sendSubscribeMessage(symbol, timeframe) {
    const broker = this.config.broker || "binance";
    this.send({
      action: "subscribe",
      broker,
      symbols: [symbol],
      types: broker === "oanda" || broker === "kraken" ? ["tick"] : ["candle"],
      // Oanda and Kraken use tick data
      interval: timeframe
    });
  }
  sendUnsubscribeMessage(symbol, _timeframe) {
    this.send({
      action: "unsubscribe",
      symbols: [symbol]
    });
  }
  send(data) {
    if (!this.manager) {
      logger15.error("Cannot send: WebSocket manager not initialized");
      return;
    }
    const message = JSON.stringify(data);
    logger15.trace("Sending message", { data });
    this.manager.send(message);
  }
  getSubscriptionKey(symbol, timeframe) {
    return `${symbol}_${timeframe}`;
  }
  disconnect() {
    logger15.info("Disconnecting WebSocket");
    this.subscriptions.clear();
    if (this.manager) {
      const ws = this.manager.getWebSocket?.();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close(1e3, "Client disconnect");
      }
    }
    this.isConnected = false;
  }
  getStatus() {
    return this.manager?.getStatus() ?? "disconnected";
  }
  getRetryCount() {
    return this.manager?.getRetryCount() ?? 0;
  }
  isConnectedStatus() {
    return this.isConnected;
  }
};
var webSocketService = null;
function getWebSocketService(config) {
  if (!webSocketService && config) {
    webSocketService = new WebSocketService(config);
  }
  if (!webSocketService) {
    throw new Error("WebSocketService not initialized. Please provide config.");
  }
  return webSocketService;
}
function destroyWebSocketService() {
  if (webSocketService) {
    webSocketService.disconnect();
  }
}

// src/hooks/useWebSocketData.ts
var logger16 = createLogger("useWebSocketData");
function useWebSocketData({
  symbol,
  timeframe,
  wsConfig,
  onUpdate,
  onRawMessage,
  enabled = true
}) {
  const [status, setStatus] = React3.useState("disconnected");
  const [retryCount, setRetryCount] = React3.useState(0);
  const [lastUpdate, setLastUpdate] = React3.useState();
  const serviceRef = React3.useRef();
  const unsubscribeRef = React3.useRef(null);
  React3.useEffect(() => {
    if (!enabled) return;
    const initWebSocket = async () => {
      try {
        setStatus("connecting");
        serviceRef.current = getWebSocketService(wsConfig);
        if (serviceRef.current.getStatus() === "disconnected") {
          await serviceRef.current.connect();
        }
        setStatus("connected");
        setRetryCount(0);
        unsubscribeRef.current = serviceRef.current.subscribe(
          symbol,
          timeframe,
          (candle) => {
            logger16.trace("Received candle update", { symbol, timeframe, candle });
            setLastUpdate(candle);
            onUpdate?.(candle);
          },
          onRawMessage
        );
      } catch (error) {
        logger16.error("Failed to connect WebSocket", { error });
        setStatus("failed");
      }
    };
    initWebSocket();
    const statusInterval = setInterval(() => {
      if (serviceRef.current) {
        const wsStatus = serviceRef.current.getStatus();
        const wsRetryCount = serviceRef.current.getRetryCount();
        setRetryCount(wsRetryCount);
        if (wsStatus === "reconnecting") {
          setStatus("reconnecting");
        } else if (wsStatus === "connected") {
          setStatus("connected");
        } else if (wsStatus === "error" || wsStatus === "disconnected") {
          setStatus("failed");
        }
      }
    }, 1e3);
    return () => {
      clearInterval(statusInterval);
      unsubscribeRef.current?.();
      if (serviceRef.current) {
        logger16.info("Disconnecting WebSocket on component unmount");
        serviceRef.current.disconnect();
      }
    };
  }, [enabled, wsConfig.url, symbol, timeframe]);
  const connect = async () => {
    if (serviceRef.current && serviceRef.current.getStatus() === "disconnected") {
      await serviceRef.current.connect();
    }
  };
  const disconnect = () => {
    serviceRef.current?.disconnect();
    setStatus("disconnected");
  };
  return {
    status,
    retryCount,
    lastUpdate,
    connect,
    disconnect
  };
}
var useTradingStore = zustand.create((set) => ({
  selectedPair: "EURUSD",
  setSelectedPair: (pair) => set({ selectedPair: pair })
}));
var MarketChartPage = ({
  symbol,
  enableTimeframeAutoSwitch = true
} = {}) => {
  const { selectedPair } = useTradingStore();
  const chartSymbol = symbol || selectedPair;
  return /* @__PURE__ */ jsxRuntime.jsx(core.Box, { style: { height: "100%", width: "100%", background: "#0a0a0a", position: "relative" }, children: /* @__PURE__ */ jsxRuntime.jsx(
    MarketDataChart_default,
    {
      symbol: chartSymbol,
      enableTimeframeAutoSwitch
    }
  ) });
};

// src/index.ts
var getChartRequestStats = () => chartDataCoordinator.getRequestStats();
var resetChartRequestStats = () => chartDataCoordinator.resetRequestStats();

Object.defineProperty(exports, "CrosshairMode", {
  enumerable: true,
  get: function () { return lightweightCharts.CrosshairMode; }
});
Object.defineProperty(exports, "LineStyle", {
  enumerable: true,
  get: function () { return lightweightCharts.LineStyle; }
});
Object.defineProperty(exports, "PriceScaleMode", {
  enumerable: true,
  get: function () { return lightweightCharts.PriceScaleMode; }
});
Object.defineProperty(exports, "createChart", {
  enumerable: true,
  get: function () { return lightweightCharts.createChart; }
});
Object.defineProperty(exports, "isBusinessDay", {
  enumerable: true,
  get: function () { return lightweightCharts.isBusinessDay; }
});
Object.defineProperty(exports, "isUTCTimestamp", {
  enumerable: true,
  get: function () { return lightweightCharts.isUTCTimestamp; }
});
exports.ADJACENT_TIMEFRAMES = ADJACENT_TIMEFRAMES;
exports.ALL_TIMEFRAMES = ALL_TIMEFRAMES;
exports.ChartDataCoordinator = ChartDataCoordinator;
exports.ChartEmptyState = ChartEmptyState;
exports.ChartErrorBoundary = ChartErrorBoundary;
exports.ChartLoadingState = ChartLoadingState;
exports.ChartSkeleton = ChartSkeleton;
exports.CountdownTimerPrimitive = CountdownTimerPrimitive;
exports.DEFAULT_TIMEFRAME = DEFAULT_TIMEFRAME;
exports.EmptyState = EmptyState;
exports.ErrorBoundary = ErrorBoundary;
exports.HTTPDataProvider = HTTPDataProvider;
exports.InlineLoader = InlineLoader;
exports.LoadingState = LoadingState;
exports.LogLevel = LogLevel;
exports.MarketChartPage = MarketChartPage;
exports.MarketDataChart = MarketDataChart_default;
exports.MinimalStreamStatus = MinimalStreamStatus;
exports.NoDataInRangeState = NoDataInRangeState;
exports.ReconnectionManager = ReconnectionManager;
exports.StreamStatus = StreamStatus;
exports.TIMEFRAME_SECONDS = TIMEFRAME_SECONDS;
exports.TIMEFRAME_SWITCH_THRESHOLDS = TIMEFRAME_SWITCH_THRESHOLDS;
exports.TimeframeWatermarkPrimitive = TimeframeWatermarkPrimitive;
exports.WebSocketReconnectionManager = WebSocketReconnectionManager;
exports.WebSocketService = WebSocketService;
exports.calculateBarSpacingForTimeframeSwitch = calculateBarSpacingForTimeframeSwitch;
exports.calculateCandleTime = calculateCandleTime;
exports.chartDataCoordinator = chartDataCoordinator;
exports.createLogger = createLogger;
exports.createPlaceholderCandle = createPlaceholderCandle;
exports.darkTheme = darkTheme;
exports.defaultChartOptions = defaultChartOptions;
exports.defaultSeriesOptions = defaultSeriesOptions;
exports.destroyHTTPDataProvider = destroyHTTPDataProvider;
exports.destroyWebSocketService = destroyWebSocketService;
exports.findLastRealCandle = findLastRealCandle;
exports.getChartRequestStats = getChartRequestStats;
exports.getCurrentCandleTime = getCurrentCandleTime;
exports.getDaysToShowForTimeframe = getDaysToShowForTimeframe;
exports.getHTTPDataProvider = getHTTPDataProvider;
exports.getMetricsSummary = getMetricsSummary;
exports.getNextCandleTime = getNextCandleTime;
exports.getTimeframePeriodSeconds = getTimeframePeriodSeconds;
exports.getVisibleRangeDuration = getVisibleRangeDuration;
exports.getWebSocketService = getWebSocketService;
exports.invoke = invoke2;
exports.isTimeVisible = isTimeVisible;
exports.listen = listen2;
exports.logger = logger;
exports.mockInvoke = mockInvoke;
exports.mockListen = mockListen;
exports.printMetricsSummary = printMetricsSummary;
exports.resetChartRequestStats = resetChartRequestStats;
exports.resetMetrics = resetMetrics;
exports.scrollToTime = scrollToTime;
exports.setVisibleRangeByDays = setVisibleRangeByDays;
exports.useChartData = useChartData;
exports.useChartDataStream = useChartDataStream;
exports.useChartSetup = useChartSetup;
exports.useChartStore = useChartStore;
exports.useChartZoom = useChartZoom;
exports.useCountdownTimer = useCountdownTimer;
exports.usePlaceholderCandle = usePlaceholderCandle;
exports.useReconnection = useReconnection;
exports.useTradingStore = useTradingStore;
exports.useWebSocketData = useWebSocketData;
exports.useWebSocketReconnection = useWebSocketReconnection;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map