var h = Object.defineProperty;
var o = (i, t, e) => t in i ? h(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var n = (i, t, e) => (o(i, typeof t != "symbol" ? t + "" : t, e), e);
const l = {};
function c(i) {
  if (i === void 0)
    throw new Error("Value is undefined");
  return i;
}
class a {
  constructor() {
    n(this, "_chart");
    n(this, "_series");
  }
  attached({ chart: t, series: e }) {
    this._chart = t, this._series = e;
  }
  detached() {
    this._chart = void 0, this._series = void 0;
  }
  get chart() {
    return c(this._chart);
  }
  get series() {
    return c(this._series);
  }
}
class u {
  constructor() {
    n(this, "_listeners", []);
  }
  subscribe(t, e, s) {
    const r = {
      callback: t,
      linkedObject: e,
      singleshot: s === !0
    };
    this._listeners.push(r);
  }
  unsubscribe(t) {
    const e = this._listeners.findIndex(
      (s) => t === s.callback
    );
    e > -1 && this._listeners.splice(e, 1);
  }
  unsubscribeAll(t) {
    this._listeners = this._listeners.filter(
      (e) => e.linkedObject !== t
    );
  }
  fire(t) {
    const e = [...this._listeners];
    this._listeners = this._listeners.filter(
      (s) => !s.singleshot
    ), e.forEach(
      (s) => s.callback(t)
    );
  }
  hasListeners() {
    return this._listeners.length > 0;
  }
  destroy() {
    this._listeners = [];
  }
}
class d extends a {
  constructor(e = {}) {
    super();
    n(this, "_options");
    n(this, "_currentRange", null);
    n(this, "_changed", new u());
    this._options = {
      ...l,
      ...e
    };
  }
  updateAllViews() {
    this._checkPriceRange();
  }
  get options() {
    return this._options;
  }
  applyOptions(e) {
    this._options = { ...this._options, ...e };
  }
  priceRangeChanged() {
    return this._changed;
  }
  getVisiblePriceRange() {
    return this._currentRange;
  }
  _checkPriceRange() {
    const e = this._measurePriceRange(), s = e === null || this._currentRange === null, r = s && e === this._currentRange;
    (s && !r || e.bottom !== this._currentRange.bottom || e.top !== this._currentRange.top) && this._changed.fire(e), this._currentRange = e;
  }
  _measurePriceRange() {
    if (!this.chart || !this.series)
      return null;
    const e = this.chart.paneSize(), s = this.series.coordinateToPrice(0), r = this.series.coordinateToPrice(e.height);
    return s === null || r === null ? null : {
      top: s,
      bottom: r
    };
  }
}
export {
  d as VisiblePriceRangeUtil
};
