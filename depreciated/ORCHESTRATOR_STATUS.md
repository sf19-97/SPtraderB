# Orchestrator Implementation Status

**Last Updated**: January 2025

## Overview

The SPtraderB trading system has evolved from having separate Orders IDE to a unified Orchestrator that handles both backtesting and live trading. Orders are now simple data structures generated by the orchestrator based on strategy rules.

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Indicators  â”‚ â”€â”€> â”‚   Signals   â”‚ â”€â”€> â”‚ Strategies â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚ ORCHESTRATORâ”‚
                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â–¼                     â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚  Backtest   â”‚       â”‚    Live     â”‚
                            â”‚    Mode     â”‚       â”‚    Mode     â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚                     â”‚
                                    â–¼                     â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚   Orders    â”‚       â”‚   Orders    â”‚
                            â”‚(Data Struct)â”‚       â”‚(Data Struct)â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚                     â”‚
                                    â–¼                     â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ Performance â”‚       â”‚  Execution  â”‚
                            â”‚  Tracking   â”‚       â”‚   Engine    â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## What's Been Done

### âœ… Completed

1. **Orders IDE Removal**
   - Deleted `/workspace/core/orders/` directory
   - Removed `OrderPreview.tsx` component
   - Updated UI to remove order references
   - Cleaned up backend order component support

2. **Basic Orchestrator Structure** (Chunk #1)
   - Created `/src-tauri/src/orchestrator/mod.rs`
   - Implemented strategy YAML loading
   - Added `StrategyConfig` parsing
   - Created test UI at `/orchestrator-test`

3. **Backtest Foundation** (Chunk #2)
   - Added `DataSource` enum (Live/Parquet)
   - Implemented environment variable pattern for data loading
   - Created `run_backtest` method that runs actual components
   - Added backtest command and UI

4. **Component Execution** (Chunk #3)
   - Modified orchestrator to actually run Python indicators and signals
   - Components execute via `run_component` with proper environment variables
   - Execution times are captured and logged
   - Real component outputs are generated (though stdout capture pending)

5. **Signal Processing** (Chunk #4) âœ… COMPLETED
   - Added data structures: `Position`, `PositionSide`, `OrderDecision`, `OrderAction`, `PositionTracker`
   - Implemented `parse_signal_output` to extract signal events from component stdout
   - Created `evaluate_entry_conditions` to process signals through strategy rules
   - Added support for comparison operators in conditions (>, <, >=, <=)
   - Matches signals against YAML entry conditions
   - Generates order decisions with proper metadata
   - Respects max positions limit from strategy parameters
   - UI displays order decisions with details

6. **Position Sizing & Risk Management** (Chunk #5) âœ… COMPLETED
   - Added `Portfolio` struct to track cash, positions, value, P&L, and drawdown
   - Implemented `RiskManager` to enforce trading limits from strategy config
   - Created `calculate_position_size` method with position limit checks
   - Added `create_order_from_decision` to generate full Order objects
   - Implemented `execute_order_simulated` with slippage simulation
   - Portfolio tracks high water mark and maximum drawdown
   - Risk checks prevent trading when limits exceeded
   - UI shows executed orders and final portfolio state

### ðŸ”„ In Progress

The orchestrator can now:
- Load strategy YAML files âœ…
- Parse configuration and dependencies âœ…
- Set up environment variables for data sources âœ…
- Run actual Python components âœ…
- Process signals through strategy rules âœ…
- Generate order decisions âœ…
- Size positions based on risk parameters âœ…
- Execute orders with risk management âœ…
- Track portfolio state and P&L âœ…
- Process candles chronologically âœ…
- Check position exits (stop loss/take profit) âœ…
- Track completed trades âœ…
- Calculate daily returns and Sharpe ratio âœ…

### âœ… Completed

1. **Performance Tracking** (Chunk #6) âœ… COMPLETED
   - Added `Candle` struct for market data representation
   - Implemented `Trade` struct to track completed trades
   - Created `load_candles` method (currently using mock data)
   - Built chronological processing loop that steps through candles
   - Implemented `check_position_exits` for stop loss/take profit checks
   - Track daily returns for Sharpe ratio calculation
   - Calculate portfolio metrics including max drawdown
   - Generate mock candles for testing purposes

### âœ… Completed

1. **Live Mode** (Chunk #7) âœ… COMPLETED
   - Added `run_live_mode` method to orchestrator
   - Subscribes to Redis stream "signals:live" for real-time signals
   - Processes signals through same entry/exit logic as backtest
   - Maintains live portfolio state with real-time updates
   - Emits portfolio updates to UI via Tauri events
   - Handles price updates for portfolio valuation
   - Implements risk limit checks to stop trading if needed
   - Created `SignalPublisher` Python utility for testing

## What's Left to Build

### Chunk #8: Unified UI
**Goal**: Production-ready orchestrator interface

```
OrchestratorPage
â”œâ”€â”€ Mode Selector (Backtest/Paper/Live)
â”œâ”€â”€ Strategy Configuration
â”œâ”€â”€ Data Source Selection
â”œâ”€â”€ Performance Dashboard
â”œâ”€â”€ Signal Monitor
â””â”€â”€ Order Flow Visualization
```

## How It Will Work

### Backtesting Flow
1. User selects strategy and historical data source
2. Orchestrator loads strategy YAML
3. Sets environment variables for data source
4. Runs indicators on historical data
5. Runs signals using indicator outputs
6. Processes signals through strategy rules
7. Generates orders with position sizing
8. Simulates execution
9. Tracks performance
10. Returns results

### Live Trading Flow
1. User selects strategy and starts live mode
2. Orchestrator loads strategy YAML
3. Subscribes to real-time data feeds
4. Runs indicators on live data
5. Runs signals in real-time
6. Processes signals through strategy rules
7. Generates orders with position sizing
8. Sends to ExecutionEngine â†’ Broker
9. Tracks actual fills
10. Updates performance in real-time

## Key Design Decisions

### 1. Environment Variable Data Pattern
Components use the same data loading pattern whether in backtest or live mode:
```python
# In component
data = load_data_from_env()  # Works for both modes
```

### 2. Stateless Components
Indicators and signals are stateless - they process data and return results. The orchestrator maintains all state.

### 3. Strategy as Configuration
Strategies are YAML files that configure how components work together. No Python code in strategies.

### 4. Orders as Data
Orders are simple Rust structs, not components. This simplifies the architecture significantly.

## Benefits of New Architecture

1. **Unified Experience**: Same interface for backtest and live
2. **Simpler Mental Model**: Clear flow from indicators â†’ signals â†’ strategies â†’ orders
3. **Better Testing**: Can test strategies without broker connection
4. **Centralized Risk**: All risk management in orchestrator
5. **Easy Transitions**: Switch from backtest â†’ paper â†’ live with one setting

## Documentation

The orchestrator implementation is now complete with comprehensive documentation:

1. **[Complete Pipeline Documentation](./ORCHESTRATOR_COMPLETE_PIPELINE.md)**
   - Full architecture overview
   - Detailed data flow for backtest and live modes
   - Component specifications
   - Integration points and API reference
   - Testing guide and troubleshooting

2. **[Flow Diagrams](./ORCHESTRATOR_FLOW_DIAGRAMS.md)**
   - Visual representations of all major flows
   - Signal processing sequences
   - Risk management decision trees
   - State machines for portfolio and orders

3. **[Quick Reference Guide](./ORCHESTRATOR_QUICK_REFERENCE.md)**
   - Common commands and examples
   - Component templates
   - Environment variables
   - Troubleshooting tips

## Current Implementation Status

All core functionality is complete:
- âœ… Strategy loading and configuration
- âœ… Component execution pipeline
- âœ… Signal processing and evaluation
- âœ… Risk management and position sizing
- âœ… Chronological backtesting
- âœ… Performance tracking with Sharpe ratio
- âœ… Live trading mode with Redis
- âœ… Real-time portfolio updates

## Next Steps

The remaining work is primarily UI/UX improvements:

1. **Chunk #8: Unified Production UI**
   - Combine test page functionality into production interface
   - Add strategy selection and configuration
   - Implement performance dashboards
   - Create position monitoring views

2. **ExecutionEngine Integration**
   - Connect live mode to existing ExecutionEngine
   - Route orders through broker APIs
   - Handle real fills and rejections

3. **Advanced Features**
   - Multiple strategy support
   - Portfolio-level risk management
   - Advanced performance analytics
   - Strategy optimization tools

## Technical Notes from Step 4

### Current Limitations
- **Stdout Capture**: `run_component` doesn't return stdout directly. Currently using mock signals for testing. Future improvement: implement proper stdout capture mechanism.
- **Symbol Hardcoded**: Symbol is hardcoded to "EURUSD" in order decisions. Should be extracted from DataSource.
- **Signal Output**: Components need to output signals between SIGNAL_START/SIGNAL_END markers in JSON format.

### Key Implementation Details
- Strategy YAML values are `serde_yaml::Value` which need conversion to `serde_json::Value` for processing
- Entry conditions support comparison operators: `">", "<", ">=", "<="`
- Parameter references like `"parameters.position_size"` are resolved from strategy config
- Position tracker maintains state throughout backtest execution

## Technical Notes from Step 5

### Key Implementation Details
- **Portfolio Management**: Portfolio tracks cash, positions, total value, daily P&L, max drawdown, and high water mark
- **Risk Manager**: Reads limits from strategy YAML (max_drawdown, daily_loss_limit, position_limit, stop_loss, take_profit)
- **Position Sizing**: Calculates quantity based on portfolio value and risk percentage, respects position size limits
- **Order Creation**: Converts OrderDecision to full Order struct with proper metadata and risk levels
- **Simulated Execution**: Applies 0.01% slippage, updates portfolio cash and positions

### Current Limitations
- **Mock Price Data**: Using hardcoded price (1.0850) instead of loading actual candles
- **No Exit Logic**: Positions remain open - no stop loss/take profit execution yet
- **Basic Metrics**: Only P&L and drawdown calculated, no Sharpe ratio or other advanced metrics
- **No Chronological Processing**: All signals processed at once rather than stepping through time

### Risk Management Features
- Maximum drawdown limit enforcement
- Daily loss limit checking
- Position size limits (max % per position)
- Maximum positions limit
- Automatic stop loss and take profit calculation

## Technical Notes from Step 6

### Key Implementation Details
- **Chronological Processing**: Backtest now steps through candles in time order, simulating realistic trading
- **Position Exit Logic**: `check_position_exits` evaluates stop loss, take profit, and signal-based exits
- **Trade Tracking**: `Trade` struct captures entry/exit details with P&L calculation
- **Daily Returns**: Tracked for Sharpe ratio calculation using 252 trading days/year convention
- **Mock Data Generation**: Creates realistic EURUSD candles with random walk + trend

### Current Limitations
- **Mock Candle Data**: Using generated data instead of loading from database
- **Mock Signals**: Still using hardcoded signals instead of component stdout
- **Basic Exit Signals**: Only checking for death_cross, not full signal evaluation
- **No Slippage on Exits**: Exit trades execute at exact stop/take profit prices

### Chrono API Updates
- Replaced deprecated `date()` with `date_naive()`
- Updated `Utc.ymd().and_hms()` to `Utc.with_ymd_and_hms()`
- Fixed type annotations for signal vectors

## Technical Notes from Step 7

### Key Implementation Details
- **Redis Integration**: Uses Redis streams with consumer groups for reliable signal delivery
- **Live Signal Processing**: `process_live_signal` reuses same logic as backtest for consistency
- **Portfolio Updates**: Real-time portfolio state emitted to UI via `portfolio_update` events
- **Risk Management**: Continuous monitoring with automatic shutdown on limit breach
- **Signal Publishing**: Python components can publish signals via `SignalPublisher` class

### Live Mode Features
- **Signal Stream**: Subscribes to `signals:live` Redis stream
- **Price Updates**: Handles real-time price feeds for portfolio valuation
- **Async Processing**: Non-blocking event loop with 1-second timeout
- **Error Handling**: Graceful handling of connection issues and invalid signals
- **State Consistency**: Same position tracking and risk management as backtest

### Python Integration
- **Signal Publisher**: `/workspace/core/data/signal_publisher.py` for publishing signals
- **Live Data Mode**: Added `realtime` mode to `loader.py` for sliding window data
- **Environment Variables**: `PUBLISH_LIVE=true` enables signal publishing from components
- **Redis Connection**: Supports custom Redis URL via environment variable

### Current Limitations
- **Mock Execution**: Still using simulated order execution (not connected to ExecutionEngine)
- **Basic Price Feed**: Using signal metadata for prices instead of dedicated feed
- **No Position Sync**: Doesn't sync existing positions from broker on startup
- **Manual Signal Publishing**: Requires running Python script to test signals

## UI Implementation Progress

### Phase 1 & 2 (Completed by User)
- **Foundation**: AppShell layout with navigation
- **OrchestratorContext**: Central state management
- **StrategyList**: Display available strategies
- **BacktestConfig**: Full configuration interface
- **BacktestRunner**: Execute backtests with real-time logs
- **BacktestResults**: Display performance metrics

### Cache Mode Enhancement (January 2025)

#### Overview
Implemented cache-based data loading to enable fast backtests using in-memory data from the chart store.

#### Components Created/Modified

1. **EnhancedDataSourceSelector** (`/src/components/orchestrator/backtest/EnhancedDataSourceSelector.tsx`)
   - Adds "Cache (Fast)" mode alongside Database and Parquet options
   - Shows real-time cache status: empty, loading, or loaded
   - "Load into Cache" button fetches data from database into memory
   - Integrates with `useChartStore` for TTL-based caching

2. **BacktestConfig** Updates
   - Replaced `DataSourceSelector` with `EnhancedDataSourceSelector`
   - Passes date range props for cache key generation
   - Maintains backward compatibility with existing modes

3. **BacktestRunner** Cache Integration
   - Imports and uses `useChartStore` hooks
   - Checks cache availability before running backtest
   - Logs cache hit/miss to execution logs
   - Shows user-friendly notifications about cache status

4. **Type Updates**
   - `BacktestConfig` interface now includes 'cache' as valid dataSource
   - `OrchestratorContext` supports cache mode throughout

#### How It Works

1. **Cache Key Generation**: Uses symbol + timeframe + date range to create unique cache keys
2. **TTL Management**: Cached data expires after 10 minutes (configurable)
3. **LRU Eviction**: Automatically removes oldest entries when cache exceeds 20 items
4. **Cache Loading**: 
   - User selects Cache mode and clicks "Load into Cache"
   - Data fetched from database via `fetch_candles` command
   - Stored in Zustand store with timestamp
5. **Cache Usage**:
   - Backtest checks cache before execution
   - If found: Uses fast in-memory data
   - If not found: Shows warning to load data first

#### Benefits
- **Performance**: Eliminates database queries for repeated backtests
- **User Experience**: Near-instant backtest execution after initial load
- **Memory Efficient**: LRU eviction prevents memory bloat
- **Transparent**: Clear UI feedback about cache status

#### Technical Notes
- Cache lives in frontend Zustand store (not backend)
- Currently falls back to database mode if cache miss
- Future enhancement: Pass cached data directly to Rust backend
- Cache persistence across page reloads via Zustand middleware (optional)

### OrchestratorChart Implementation (January 2025)

#### Overview
Created a specialized charting component for the orchestrator that extends PreviewChart functionality with trading-specific visualizations.

#### Components Created

1. **OrchestratorChart** (`/src/components/orchestrator/OrchestratorChart.tsx`)
   - Extends PreviewChart with orchestrator-specific features
   - Supports two display modes:
     - **Candles Mode**: Shows price data with trade overlays
     - **Equity Curve Mode**: Displays portfolio value over time
   - Integrates seamlessly with BacktestResults

2. **TradeOverlay** (`/src/components/orchestrator/charts/TradeOverlay.tsx`)
   - Renders trade markers on top of price charts
   - Features:
     - Entry/exit arrows with directional indicators
     - Stop loss and take profit visualization
     - P&L labels on closed trades
     - Trade summary statistics in fullscreen mode
   - Visual distinctions:
     - Green up arrows for long entries
     - Red down arrows for short entries
     - X markers for exits
     - Connecting lines colored by P&L

3. **BacktestResults Enhancement**
   - Added tabbed interface with three views:
     - **Overview**: Original statistics and metrics
     - **Chart**: Interactive chart with trade visualization
     - **Trades**: Detailed trade history table
   - Transforms backtest data for chart display
   - Generates equity curve from portfolio values

#### Key Features

1. **Trade Visualization**
   - Entry/exit points clearly marked on chart
   - Stop loss and take profit lines for open positions
   - P&L displayed on closed trades
   - Trade summary overlay in fullscreen mode

2. **Equity Curve**
   - Line chart showing portfolio value over time
   - Trade markers on equity curve
   - Starting capital reference line
   - Shaded area under curve for visual impact

3. **Data Integration**
   - Reuses cached candle data from backtest
   - Transforms executed orders into trade objects
   - Calculates price scales for accurate overlay positioning

#### Benefits
- **Visual Analysis**: See exactly where trades occurred on price chart
- **Performance Review**: Equity curve shows portfolio growth/drawdown
- **Code Reuse**: Leverages existing PreviewChart component
- **Minimal Overhead**: Overlay approach keeps charts performant

#### Technical Implementation
- Canvas-based overlay for trade markers (no DOM overhead)
- Responsive design with fullscreen support
- Proper coordinate transformation for accurate positioning
- Tab-based UI keeps interface organized

#### Usage
The OrchestratorChart is automatically displayed in BacktestResults after a successful backtest run. Users can:
1. Switch between Overview, Chart, and Trades tabs
2. Toggle between candle chart and equity curve views
3. View trade details by hovering over markers
4. Export trade history as CSV

## Current Implementation Status (January 2025)

### âœ… Real Component Execution Implemented
The orchestrator now executes actual Python components during backtesting:

**Implementation Details:**
1. **Component Runner Module** (`component_runner.rs`):
   - Executes Python indicators and signals with proper environment variables
   - Serializes candle data to JSON for component consumption
   - Parses component output between INDICATOR_START/END and SIGNAL_START/END markers
   - Supports both single and multi-indicator outputs

2. **Execution Flow**:
   ```rust
   // For each candle in backtest:
   execute_components_for_candle() ->
     1. Run all indicators with candle data
     2. Collect indicator outputs
     3. Run signals with indicator data
     4. Parse and validate signal timestamps
     5. Return signals for strategy evaluation
   ```

3. **Environment Variables Passed to Components**:
   - `CANDLE_DATA`: JSON array of candles up to current index
   - `CURRENT_INDEX`: Index of current candle being processed
   - `SYMBOL`: Trading symbol (e.g., "EURUSD")
   - `TIMEFRAME`: Candle timeframe (e.g., "1h")
   - `COMPONENT_TYPE`: "indicator" or "signal"
   - `INDICATOR_DATA`: (for signals) JSON map of indicator outputs

4. **Test Components Created**:
   - `/workspace/core/indicators/test_sma.py`: Simple moving average indicator
   - `/workspace/core/signals/test_crossover.py`: MA crossover signal detector
   - `/workspace/strategies/test_real_execution.yaml`: Test strategy using real components

### Key Features
- **Stdout/Stderr Capture**: RunResult now includes full stdout/stderr content
- **Proper Timestamp Filtering**: Only signals within current candle's time window are processed
- **Error Handling**: Failed components log warnings but don't crash backtest
- **Performance**: Component outputs can be cached (future optimization)

### Testing the Implementation
To test real component execution:
1. Use the `test_real_execution` strategy
2. Run a backtest with sufficient data (30+ days)
3. Components will execute for each candle
4. Signals will be generated based on actual calculations

### Remaining Optimizations
1. **Component Caching**: Cache indicator values to avoid recalculation
2. **Parallel Execution**: Run independent indicators in parallel
3. **Incremental Computation**: Only compute new values, not entire history
4. **Enhanced Metadata**: Support v2 metadata format for parameterized indicators